\documentclass[
%,hyperref={pdfpagelabels=false}
,xcolor=dvipsnames
]{beamer}
% Die Hyperref Option hyperref={pdfpagelabels=false} verhindert die Warnung:
% Package hyperref Warning: Option `pdfpagelabels' is turned off
% (hyperref)                because \thepage is undefined.
% Hyperref stopped early

\usepackage{agstyle}
\usepackage{currycode}
\usepackage{todonotes}
\presetkeys{todonotes}{inline}{}

\newcommand{\ergo}{$\Rightarrow$}
\newcommand{\pro}{\makebox[1ex]{\color{Green}\bfseries +}}
\newcommand{\con}{\makebox[1ex]{\color{Red}  \bfseries \textendash}}

\newcommand{\blocktitle}[1]{%
{\medskip\usebeamerfont{subtitle}\usebeamercolor[fg]{subtitle}#1\smallskip}
}

\newcommand{\comment}[1]{\textsl{-{}- #1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Implementing Residuation in KiCS2}
\date{May (07 ? 08), 2013}
\author[Björn Peemöller]{\texorpdfstring
{Björn Peemöller\\\texttt{bjp@informatik.uni-kiel.de}}
{Björn Peemöller}
}
\institute{Kiel University}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Curry}
\framesubtitle{A functional logic programming language}

\begin{itemize}
\item Haskell-like syntax
\item non-strict semantics, lazy evaluation
\item extended by non-determinism, free variables, unification
\end{itemize}

\begin{curry}[Example of Curry Syntax]
data Bool = False | True \medskip
aBool :: Bool
aBool = False ? True \medskip
not :: Bool -> Bool
not True  = False
not False = True \medskip
ensureTrue :: Bool -> Success
ensureTrue True  = success
ensureTrue False = failed
\end{curry}
\end{frame}

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Operational Semantics of Curry}

\begin{kics2}[Deterministic values]
kics2> \textsl{map not [False, True]}
[True,False]
\end{kics2}
\pause
\begin{kics2}[Non-Deterministic values]
kics2> \textsl{not (False ? True)}
True
False
No more values.
\end{kics2}
\pause
\begin{kics2}[Failing computation]
kics2> \textsl{ensureTrue False}
!
kics2> \textsl{ensureTrue True}
Success
\end{kics2}
\end{frame}

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Evaluation using Narrowing}

\blocktitle{Behaviour}

\begin{itemize}
\item Function application is non-deterministic w.r.t free variables
\item Function application \emph{instantiates} free variables \\
      $\leadsto$ construction of search space
\end{itemize}

\blocktitle{Characteristics}

\begin{itemize}
\item[\pro] Complete evaluation strategy
\item[\pro] Optimality results
\item[\con] Non-deterministic function application
\item[\con] Difficult integration of external functions
            (non-deterministic arguments)
\end{itemize}

\begin{kics2}[Narrowing of Free Variables]
kics2> \textsl{not x where x free}
\{x = False\} True
\{x = True\} False
\end{kics2}
\end{frame}

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Evaluation using Residuation}

\blocktitle{Behaviour}

\begin{itemize}
\item Function application is deterministic
\item Function application \emph{suspends} on free variables
\item Suspended computations can be continued via concurrent bindings
\end{itemize}

\blocktitle{Characteristics}

\begin{itemize}
\item[\con] Incomplete evaluation strategy
\item[\pro] Deterministic function application
\item[\pro] Simple integration of external functions (deterministic arguments)
\item[\pro] Support for concurrent programming
            (communication through shared logic variables)
\end{itemize}

\begin{kics2}[Residuation on Free Variables]
kics2> \textsl{x + 1 =:= 2 where x free}
Goal suspended!
kics2> \textsl{x + 1 =:= 2 & x =:= 1 where x free}
\{x = 1\} Success
\end{kics2}
\end{frame}

% \begin{frame}[fragile]%---------------------------------------------------------
% \frametitle{Evaluation strategies in Curry}
% 
% 
% \blocktitle{Curry supports a combination of narrowing and residuation}
% 
% \begin{itemize}
% \item \emph{Narrowing} for functions defined via pattern matching
% \item \emph{Residuation} for functions defined using (rigid)
%       \code{case}-expressions
% \item Support for primitive \emph{residuation} operator
% 
% \begin{curry}[Primitive residuation operator \code{ensureNotFree}]
% ensureNotFree :: a -> a
% ensureNotFree external
% \end{curry}
% \end{itemize}
% 
% \end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{KiCS2 Curry Compiler}

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{The KiCS2 Curry Compiler}
\begin{itemize}
\item KiCS2 is a compiler from Curry to Haskell
\item Non-determinism is explicitly represented in
      the Haskell data structures
\item Unique identifiers are used to obtain
      call-time choice semantics
\item Optimizations for deterministic and higher order functions
\item Various other features (functional patterns, set functions, \dots)
\item \emph{Currently no support for residuation}
\end{itemize}
\end{frame}

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Runtime Representation in KiCS2}

The search space is explicitly represented in data types
\begin{haskell}[Representation of the Curry type \code{Bool}]
data C_Bool
  = C_False
  | C_True
  | Choice_C_Bool ID C_Bool C_Bool
  | Fail_C_Bool
  | Guard_C_Bool Constraints C_Bool
\end{haskell}
%   | Choices_C_Bool ID [C_Bool]      -- free variables

A value of type \code{ID} identifies choices to allow consistent decisions
\begin{haskell}[Choice Identifier]
data ID = ChoiceID Integer
        | FreeID Integer
\end{haskell}
\end{frame}

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Constraint Representation in KiCS2}

\begin{itemize}
\item Constraints are used to limit the search space
\item They are normally introduced by unification
\end{itemize}

\begin{haskell}[Search Space Constraints]
data Constraints = StructC [Constraint] \medskip
data Constraint = ID :=: Decision \medskip
data Decision = NoDecision
              | ChooseLeft
              | ChooseRight
\end{haskell}
%              | ChooseN Int
\end{frame}

\begin{frame}[fragile]%-------------------------------------------------------
\frametitle{Top-Level Search}

\begin{itemize}
  \item Traverses generic representation of search space
  \item Uses global decision store (\code{IO} monad)
\end{itemize}

\begin{haskell}[Depth-first-search]
dfs :: Curry a => Try a -> IO ()
dfs (Val x)        = print x
dfs Fail           = return ()
dfs (Choice i l r) = lookupDecision i >>= follow
  where
  follow ChooseLeft  = dfs (try l)
  follow ChooseRight = dfs (try r)
  follow NoDecision  = decide i ChooseLeft l >> decide i ChooseRight r \medskip
  decide i c x = do setDecision i c >> dfs (try x)
                    setDecision i NoDecision
dfs (Free i l r)   = \comment{like Choice, but unbound variables are printed}
dfs (Guard cs e)   = solve cs (dfs try e)
\end{haskell}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation of Residuation}

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Representation of Residuation}

\blocktitle{Implementation idea}

\begin{itemize}
\item Residuation is represented by extending the constraints
\item Constraint takes the \code{ID} of the variable it suspends on
\item The search should \emph{suspend} if the variable is not yet bound
\end{itemize}

\begin{haskell}
data Constraints = StructC [Constraint]
                 \alert{| SuspendedC ID}
\end{haskell}

\end{frame}

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Suspending Operations}

Residuation is introduced in the primitive operation \code{ensureNotFree}

\begin{haskell}[Implementation of \code{ensureNotFree}]
ensureNotFree :: Curry a => a -> a
ensureNotFree x = case try x of
  Val x        -> x
  Choice i l r -> mkChoice i (ensureNotFree l) (ensureNotFree r)
  \alert{Free i xs    -> mkGuard (SuspendedC i) (mkChoices i xs)}
  Fail         -> mkFail
  Guard cs e   -> mkGuard cs (ensureNotFree e)
  \ldots
\end{haskell}

\pause

Rigid case expressions are translated to use \code{ensureNotFree}

\begin{example}[Translation of rigid \code{case}-expressions]
case $e$ of $alts$ $\to$ fcase\footnotemark~(ensureNotFree $e$) of $alts$
\end{example}
\footnotetext{\code{fcase} denotes a flexible \code{case}-expression
allowing for narrowing}
\end{frame}

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Concurrent Constraints}

\begin{itemize}
\item In the presence of residuation, the \code{(\&)}-operator
      for constraint combination must support concurrency
\item The constraints must not be solved before the top-level search
\item[\ergo] Need for representation of concurrent constraints
\end{itemize}

% \begin{haskell}
% (\&) :: C_Success -> C_Success -> C_Success
% C_Success              \& s = s
% Fail_C_Success         \& _ = Fail_C_Success
% Choice_C_Success i a b \& s = Choice_C_Success i (a \& s) (b \& s)
% Choices_C_Success i xs \& s = Choices_C_Success i (map (\& s) xs)
% Guard_C_Success cs e   \& s = Guard_C_Success cs (e \& s)
% \end{haskell}

\begin{haskell}
data Constraints = \ldots \alert{| ConcurrentC [Constraints]}
\end{haskell}
\end{frame}

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Concurrent Constraint Combination}

\begin{haskell}[Implementation of the concurrent \code{(\&)}-operator]
(\&) :: C_Success -> C_Success -> C_Success
C_Success              \& s = s
Fail_C_Success         \& _ = Fail_C_Success
Choice_C_Success i a b \& s = Choice_C_Success i (a \& s) (b \& s)
Guard_C_Success c e    \& s = case s of
  Guard_C_Success d f -> \alert{combine c d e f}
  _                   -> Guard_C_Success c (e \& s)
  where
  \alert{combine c d e f = Guard_C_Success (ConcurrentC [c, d]) (e \& f)}
\end{haskell}
\end{frame}

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Extending the Top-Level Search}

Suspended constraints are evaluated once the variable is bound

\begin{haskell}[Top-Level Search with Support for Residuation]
dfs :: Curry a => \alert{[Constraints] ->} Try a -> IO ()
\ldots
dfs suspended (Val x)
  \alert{| not (null suspended) = putStrLn "Goal suspended!"}
  | otherwise            = print x
dfs suspended (Choice i l r) = lookupDecision i >>= follow
  where
  follow ChooseLeft  = dfs (try l)
  follow ChooseRight = dfs (try r)
  follow NoDecision  = decide i ChooseLeft l >> decide i ChooseRight r \medskip
  decide i d x       = do setDecision i d
                          \alert{wakeUp i suspended (try x)}
                          setDecision i NoDecision
dfs suspended (Free   i l r) = \comment{same as Choice, but stops if suspended}
\end{haskell}
\end{frame}

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Promoting Suspended Constraints}

\blocktitle{Problems with the current implementation of \code{(\&)}}
\begin{itemize}
\item If a constraint might suspend, its bindings take effect not
      until all other constraints are solved
\item Unsuspended bindings may be suspended by a concurrent constraint
\end{itemize}

\begin{example}[Unnecessarily suspended constraint]
\begin{columns}[t]
\column{.4\textwidth}
\begin{semiverbatim}
(x + 1 =:= 2 &> y =:= 1) &
 y + 1 =:= z             &
 x     =:= 1
  where x,y,z free
\end{semiverbatim}
\column{.55\textwidth}
\begin{itemize}
\item first  constraint suspends on \code{x}
\item Second constraint suspends on \code{y}
\item Third  constraint binds \code{x}
\item Binding of \code{y} still suspends on \code{y}!
\end{itemize}
\end{columns}
\end{example}
\end{frame}

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Promoting Suspended Constraints (cont.)}

\begin{itemize}
\item Suspended constraints are solved once they no longer suspend
\item These constraints may themselves suspend later
\end{itemize}

\begin{haskell}[Improved implementation of the \code{(\&)}-operator]
data Constraints = \ldots | SuspendedC ID \alert{C_Success} \medskip
\ldots \comment{same rules as before}
Guard_C_Success c e    \& s = case s of
  Guard_C_Success d f -> combine c d e f
  _                   -> Guard_C_Success cs (e \& s)
  where
  combine c d e f = let (cs1, e1) = promote c e
                        (cs2, e2) = promote d f
                    in Guard_C_Success (ConcurrentC (cs1 ++ cs2))
                                       (e1 \& e2) \medskip
  promote (ConcurrentC cs) x = (cs                    , x        )
  \alert{promote (SuspendedC i s) x = ([SuspendedC i (s \& x)], C_Success)}
  promote s@(StructC    _) x = ([x]                   , x        )
\end{haskell}

\end{frame}


\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Concurrent Objects using Residuation}

\begin{curry}[Concurrent bank account]
data Message = Deposit Int | Withdraw Int | Balance Int

account :: Int -> [Message] -> Success
account _ []                 =  success
account n (Deposit  a : ms)  =  account (n + a) ms
account n (Withdraw a : ms)  =  account (n - a) ms
account n (Balance  b : ms)  =  b =:= n \& account n ms

make_account s = account 0 (ensureSpine s) \comment{create bank account}

goal b = make_account s
       \& s =:= [Deposit 100, WithDraw 50, Balance b]
\end{curry}

\begin{kics2}
kics2> goal b where b free
\{b = 50\} Success
\end{kics2}

\end{frame}

\section{Conclusion}

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Conclusion}

\blocktitle{Status quo}
\begin{itemize}
\item Prototype implementation of residuation in KiCS2
\item Allows for concurrent solving of constraints
\end{itemize}

\blocktitle{Future Work}
\begin{itemize}
\item Improve the management of suspended constraints
\item Change externally defined functions to use residuation
\end{itemize}

\end{frame}

\appendix

\begin{frame}[fragile]%---------------------------------------------------------
\frametitle{Improving Management of Suspended Constraints}

\blocktitle{Disadvantages}
\begin{itemize}
\item[\con] Explicit data structure for suspended cosntraints requires
            all search strategies to be extended
\item[\con] All suspended constraints must be traversed during wake up
\end{itemize}

\blocktitle{Possible Solution: Extend decision store to save suspended constraints}
\begin{itemize}
\item[\pro] Residuation is handled in constraint solver component
\item[\pro] Residuation gets independent form search implementation\\
            \ergo available for all search strategies
\item[\pro] Suspended constraint are automatically retrieved when
            a decision is made \\
            \ergo no traversal necessary
\item[\con] Problematic: How to query absence of suspended constraints
\end{itemize}
\end{frame}


\end{document}
