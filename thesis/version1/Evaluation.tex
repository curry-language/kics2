\section{Evaluation}
In diesem Kapitel soll die vorgestellte Erweiterung von KiCS2 um eine Finite Domain Constraint Bibliothek und die Integration extern implementierter FD-Solver mit Hilfe einiger Benchmarks evaluiert werden.
\\
Alle Benchmarks wurden auf einem PC mit Intel Core 2 Duo (3 GHz) Prozessor und 3 GB Arbeitsspeicher unter Ubuntu 12.04 ("'Precise Pangolin"') durchgeführt. Dabei wurde KiCS2 Version 0.2 mit dem Glasgow Haskell Compiler (GHC Version 7.4.1) ausgeführt. Mit Hilfe der \lstinline|time|-Option von KiCS2 wurde jeweils die Ausführungszeit in Sekunden gemessen und dann der Mittelwert von drei Messdurchläufen berechnet. Falls ein Benchmark-Programm innerhalb von 10 Minuten kein Ergebnis geliefert hat, wird dies bei den Messergebnissen durch "'n.a."' kenntlich gemacht.
\\
Zunächst wurde getestet, inwieweit sich das "'nach oben"' Verschieben von \lstinline|Guard|-Ausdrücken mit Bindungsconstraints im KiCS2-Auswertungsbaum sowie das zusätzliche Ablaufen dieses Baumes zur Suche nach \lstinline|WrappedConstraint|s mittels \lstinline|searchWrappedCs| auf die Auswertung von Ausdrücken auswirkt, die keine Finite Domain Constraints enthalten. Dazu wurden die Benchmarks für die Unifikation, die KiCS2 zur Verfügung stellt (\emph{UnificationBench.curry}), einmal mit und einmal ohne die CLPFD-Erweiterung ausgeführt. Zu den Benchmark-Programmen gehören \lstinline|last| (Berechnung des letzten Elements einer Liste), \lstinline|grep| (Matching eines Wortes mit einem regulären Ausdrucks), \lstinline|halfPeano| (Halbierung einer Peano-Zahl), \lstinline|varInExp| (Suche nach einer Variable in einem arithmetischen Ausdruck), \lstinline|simplify| (Vereinfachung eines arithmetischen Ausdrucks), \lstinline|palindrome| (Überprüft, ob eine Liste ein Palindrom ist) und \lstinline|horseMan| (Lösung einer Gleichung bezüglich der Köpfe und Beine von Pferden und Menschen):
\begin{figure}[!h]
\begin{center}
\begin{tabular}{|l|*{2}{r|}}
\hline
Benchmark  & KiCS2 & KiCS2 + CLPFD  \\\hline
\lstinline|last|       &   1.18  &   1.18  \\
\lstinline|grep|       &   1.14  &   1.24  \\
\lstinline|halfPeano|  &  53.17  &  54.1   \\
\lstinline|varInExp|   &   2.01  &   n.a.  \\
\lstinline|simplify|   &  54.56  &  95.75  \\
\lstinline|palindrome| &  64.3   &  85.93  \\
\lstinline|horseMan|   &  11.58  &  14.79  \\
\hline
\end{tabular}
\caption{Benchmarks: Unifikation in KiCS2 ohne und mit CLPFD-Erweiterung}
\end{center}
\end{figure}
\\
Wie man an den Ergebnissen sieht, benötigt die erweiterte KiCS2-Version in fast allen Fällen länger als die ursprüngliche Version. Dies hängt vermutlich in erster Linie mit dem "'Hochziehen"' der \lstinline|Guard|-Ausdrücke mit Bindungsconstraints im KiCS2-Auswertungsbaum zusammen. Besonders extrem wirkt sich dies auf den \lstinline|varInExp|-Benchmark aus, bei dem versucht wird, die einzige Variable in einem tief verschachtelten arithmetischen Ausdruck (25.000 Knoten) mit Hilfe der Unifikation zu finden.
\\
Auch die Vereinfachung eines arithmetischen Ausdrucks mit 4003 Knoten benötigt fast doppelt so lange, wenn man die erweiterte KiCS2-Version verwendet. Bei den übrigen Benchmarks bleibt der Overhead für die CLPFD-Erweiterung hingegen im Rahmen.
\par
In einem weiteren Benchmark wurde die Performance der Finite Domain Solver anhand des N-Damen-Problems verglichen. Betrachtet wurden dabei eine generate\&test-Variante des N-Damen-Problems ohne FD-Constraints (siehe Anhang \ref{anhangE}), die Lösung des CLPFD-Modells (vergleiche Code-Listing 70) mit den beiden MCP-FD-Solvern, wobei jeweils einmal die \lstinline|InOrder|- und einmal die \lstinline|FirstFail|-Labeling-Strategie getestet wurden, und der direkte Aufruf des Gecode-Solvers ohne KiCS2 mit dem im Grundlagenkapitel vorgestellten MCP-Modell (vergleiche Code-Listing 45).
\begin{figure}[!h]
\begin{center}
\begin{tabular}{|*{7}{r|}}
\hline
n  & gen. \& test & \multicolumn{2}{c|}{Overton} & \multicolumn{2}{c|}{Gecode} & Gecode (direkt) \\\hline
   &           & \lstinline|InOrder|   & \lstinline|FirstFail| & \lstinline|InOrder|   & \lstinline|FirstFail| & \lstinline|FirstFail| \\\hline
%1  &  $<$0.01  &  $<$0.01  &  $<$0.01  &  $<$0.01  &  $<$0.01  &  $<$0.01  \\
%2  &  $<$0.01  &  $<$0.01  &  $<$0.01  &  $<$0.01  &  $<$0.01  &  $<$0.01  \\
%3  &  $<$0.01  &  $<$0.01  &  $<$0.01  &  $<$0.01  &  $<$0.01  &  $<$0.01  \\
4  &     0.04  &  $<$0.01  &  $<$0.01  &  $<$0.01  &  $<$0.01  &  $<$0.01  \\
5  &     0.66  &     0.02  &     0.02  &     0.02  &     0.02  &     0.01  \\
6  &    11.12  &     0.03  &     0.03  &     0.02  &     0.02  &     0.02  \\
7  &   225.99  &     0.13  &     0.10  &     0.07  &     0.04  &     0.03  \\
8  &     n.a.  &     0.48  &     0.38  &     0.18  &     0.09  &     0.07  \\
9  &     n.a.  &     2.28  &     1.82  &     0.74  &     0.29  &     0.20  \\
10 &     n.a.  &    10.16  &     8.45  &     2.64  &     0.86  &     0.65  \\
11 &     n.a.  &    51.62  &    43.14  &    13.16  &     3.58  &     2.80  \\
12 &     n.a.  &   301.06  &   248.87  &    83.95  &    18.91  &    14.26  \\
\hline
\end{tabular}
\caption{Benchmarks: Performance der Solver im Vergleich}
\end{center}
\end{figure}
Die Benchmarks zeigen, dass die generate\&test-Implementierung des N-Damen-Problems für größere n nicht mit den FD-Solvern konkurrieren kann. Bereits die Berechnung des 8-Damen-Problems benötigt länger als zehn Minuten. Die MCP-FD-Solver lösen das gleiche Problem in unter einer Sekunde. Auch für größere n-Werte berechnen beide Solver die Lösungen in einer akzeptablen Zeit.
\\
Wie zu erwarten war, ist der auf C++-basierende Gecode-Solver allerdings erheblich schneller als der in Haskell realisierte Overton-Solver. Durch Einsatz einer vorteilhaften Labeling-Strategie wie \lstinline|FirstFail|, bei der die Labeling-Variablen mit dem am weitesten eingeschränkten Wertebereich bevorzugt werden, können die Zeiten für beide MCP-Solver noch einmal erheblich verbessert werden.
\\
Vergleicht man den direkten Aufruf des Gecode-Solvers über das MCP-Framework mit dem Aufruf dieses Solvers über KiCS2, so zeigt sich, dass die Performance fast gleich ist. Erst bei der Lösung größerer Modelle wirkt sich der zusätzliche Übersetzungsschritt, der in KiCS2 durchgeführt werden muss, auf die Ausführungszeiten aus.

