\section{Einführung}
\label{chapter_einfuehrung}
Constraint Programming befasst sich mit der Lösung von Problemen durch Spezifikation von Eigenschaften und Bedingungen (= Constraints), die von möglichen Lösungen dieses Problems erfüllt werden müssen. Man definiert diese Bedingungen deklarativ durch das Aufstellen von Regeln für Variablen, die einen endlichen oder unendlichen Wertebereich besitzen. Die Modellierung eines Problems mit endlichem Wertebereich wird auch als Finite Domain Constraint Programming bezeichnet.
\par
Ein Constraint Programming System besteht im wesentlichen aus zwei Elementen: einer Modellierungskomponente, mir deren Hilfe das zu lösende Problem beschrieben wird, und einer Lösungskomponente, einem sogenannten Constraint-Solver, der nach Lösungen für das beschriebene Problem sucht. Dazu speichert, kombiniert und vereinfacht der Solver die Constraints eines Modells mit Hilfe spezieller Algorithmen. Mit Hilfe der Labeling-Technik "'probiert"' er Variablenbelegungen aus und propagiert diese (Constraint Propagierung), um auf diese Weise den Wertebereich weiterer Constraint-Variablen einzuschränken. Diese Techniken werden iterativ angewandt, bis entweder eine gültige Belegungen für alle Constraint-Variablen gefunden wurde oder bis ein Widerspruch auftritt. In diesem Fall "'springt"' der Solver in einen konsistenten Zustand zurück und probiert eine andere Belegungen aus (Backtracking).
\par
Zu den Anwendungsgebieten des Constraint-Programmings zählen die Erstellung von Fahr-, Personaleinsatz- und Stundenplänen. Neben logischen Sprachen wie PROLOG, die spezielle Constraint-Programming-Bibliotheken zur Verfügung stellen, gibt es auch eine ganze Reihe von Softwaresystemen zur Modellierung und Lösung von Constraint-Problemen. Beispiele hierfür sind die auf C++-basierende Solver-Bibliothek Gecode (Generic Constraint Development Environment \cite{Gecode}) oder das in der Objekt-orientierten Programmiersprache Java realisierte TAILOR-Tool (\cite{Gent:2007:TSC:1770681.1770699}), das in der Solver-unabhängigen Modellierungssprache Essence' modellierte Constraint-Probleme mit Hilfe des Minion oder Gecode Solvers löst.
\\
Im Bereich der funktionalen Programmierung haben Tom Schrijvers, Peter Stuckey und Philip Wadler mit ihrem Monadic Constraint Programming Framework (kurz: MCP-Framework, \cite{234095}) gezeigt, wie man einen Finite Domain Constraint Solver mit Hilfe von Monaden in der seiteneffektfreien Sprache Haskell implementieren kann. 
\par
Auf den ersten Blick ist auch die funktional-logische Programmiersprache Curry gut für die Einbettung einer Constraint-Modellierungssprache geeignet: So unterstützt Curry die Programmierung mit freien Variablen und bietet einen deklarativen Programmierstil. Allerdings gilt in Curry das Prinzip der referentiellen Transparenz, es handelt sich also um eine zustandslose, seiteneffektfreie Sprache. Dies erschwert die direkte Realisierung stark zustandsbehafteter Constraint-Solver in Curry. 
\\
Diese Arbeit hat sich zum Ziel gesetzt, die KiCS2-Curry-Implementierung, die funktional-logische Programme in rein funktionale Haskell-Programme übersetzt, um die Möglichkeit zur Programmierung mit Finite Domain Constraints zu erweitern. Dazu soll eine Finite Domain Constraint Bibliothek für KiCS2 entwickelt werden. Gelöst werden sollen diese Constraints mit Hilfe der FD-Solver des Monadic Constraint Programming Frameworks (\cite{234095}), die daher in die KiCS2-Implementierung integriert werden sollen. Schließlich sollen die wichtigsten Erkenntnisse aus dieser Integration abgeleitet werden und in die Entwicklung generischer Schnittstellen zur Einbindung weiterer Constraints und Constraint-Solver in KiCS2 fließen. In einem letzten Schritt sollen diese Schnittstellen beispielhaft für die zuvor entwickelte FD-Constraint-Bibliothek und die MCP-FD-Solver implementiert werden.
\par
Das nächste Kapitel liefert eine kurze Übersicht über die wichtigsten Grundlagen, die zum Verständnis dieser Arbeit erforderlich sind. Dazu werden in einzelnen Unterkapiteln die Programmiersprache Curry, die KiCS2-Curry-Implementierung sowie das Monadic Constraint Programming Framework vorgestellt. Kapitel 3 beschreibt die grundlegende Idee für die Implementierung von Finite Domain Constraints in KiCS2. In Kapitel 4 wird die Implementierung vorgestellt. Es ist in drei größere Unterabschnitte unterteilt, die sich mit der Entwicklung einer CLPFD-Bibliothek für KiCS2, der Integration der Finite Domain Solver des MCP-Frameworks sowie der Entwicklung generischer Schnittstellen zur Integration weiterer Constraints und Constraint-Solver befassen. Kapitel 5 evaluiert die hier vorgestellte Implementierung mit Hilfe geeigneter Benchmarks. Und das letzte Kapitel liefert eine Zusammenfassung sowie einen Ausblick auf mögliche Weiterentwicklungen.




\clearpage
