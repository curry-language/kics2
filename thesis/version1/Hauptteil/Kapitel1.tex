\section{Vorüberlegungen und Grundlegende Idee}
\label{chapter_idee}
Das Ziel dieser Arbeit ist die Integration von Constraint-Solvern in die funktional-logische Sprache Curry. Genauer gesagt, sollen generische Schnittstellen zum Einbinden von Constraint-Bibliotheken und zum Anschluss von Constraint-Solvern für die KiCS2-Curry Implementierung entwickelt werden. Getestet werden sollen diese Schnittstellen durch die Entwicklung eines Finite Domain Constraint Programming Systems bestehend aus einer Finite Domain Constraint Bibliothek und der beispielhaften Integration der Solver des Monadic Constraint Programming Frameworks in KiCS2.
\par
Ein Constraint-Programming System besteht in der Regel aus einer Modellierungseinheit zur Beschreibung des Problems und einer Komponente zur Lösung des modellierten Problems. Ein Problem wird dabei durch Angabe von Regeln, Eigenschaften oder Beschränkungen (Constraints) für sogenannte Constraint-Variablen beschrieben. Diese Problembeschreibung erfolgt häufig mit Hilfe einer speziellen Modellierungssprache. Die Solver-Komponente versucht dann durch Einsatz verschiedener Techniken wie Constraint-Propagierung oder Labeling von Variablen (= "Ausprobieren" von Variablenbelegungen), Lösungen für das modellierte Problem zu finden.
\\
Curry ist aufgrund seines deklarativen Stils und der Unterstützung logischer Features wie der Programmierung mit freien Variablen gut für die Einbettung einer Constraint-Modellierungssprache geeignet. Die direkte Implementierung eines Constraint-Solvers in Curry wird jedoch durch das Prinzip der referentiellen Transparenz erschwert. Dieses besagt, dass der Wert eines Ausdrucks nur von dessen Umgebung und nicht vom Zeitpunkt oder der Reihenfolge der Auswertung abhhängt. Anders formuliert Curry ist eine zustandslose Sprache ohne Seiteneffekte. 
\\
Dies wird bei der Implementierung eines Constraint-Solvers zum Problem, denn ein solcher verwendet üblicherweise einen sogenannten Constraint-Speicher zur Verwaltung der Constraints. Solange alle Constraints im Speicher erfüllbar sind, befindet sich der Solver in einem konsistenten Zustand. Durch das Eintragen weiterer Constraints kann sich dieser Zustand aber jederzeit ändern. Diese zustandsorientierten Berechnungen sind in einer seiteneffektfreien Sprache jedoch nicht oder wenn dann nur unter Einsatz spezieller Konzepte implementierbar.
\\
Beispielsweise gibt es in der funktionalen Sprache Haskell, die ebenfalls referentiell transparent ist, das Konzept der Monade zur Realisierung seiteneffektbehafteter Berechnung: Durch Haskells lazy evaluation ist die Auswertungsreihenfolge relativ unvorhersehbar. Für bestimmte Anwendungen wie zum Beispiel das Lesen einer Datei, die Ausgabe eines Textes auf die Kommandozeile oder eben die Aktualisierung eines Constraint-Speichers ist jedoch eine feste Ausführungsabfolge entscheidend. Mit Monaden kann man die sequentielle Ausführung derartiger seiteneffektbehafteter Berechnungen garantieren.
Wie Tom Schrijvers, Peter Stuckey und Phil Wadler gezeigt haben, ist es mit Hilfe von Monaden auch möglich, einen Constraint-Solver direkt in Haskell zu implementieren \textcolor{red}{$<$hier Verweis auf Quellen$>$}. 
\\
Effizientere und besser optimierte Solver-Bibliotheken wurden allerdings in imperativen Sprachen wie C++ oder Java realisiert \textcolor{red}{$<$hier Verweis auf Quellen$>$}. Daher ist das Ziel dieser Arbeit nicht die direkte Realisierung eines Curry-Constraint-Solvers, sondern vielmehr die Entwicklung einer generischen Schnittstelle, mit deren Hilfe man extern implementierte Solver in Curry integrieren kann.
\\
Wie bereits erwähnt, wird für die Entwicklung die KiCS2-Curry-Implementierung verwendet, die funktional-logische Curry-Programme in rein funktionale Haskell-Programme übersetzt. Das bedeutet, KiCS2 bildet alle Datentypen und -Funktionen eines Curry-Programms auf entsprechende Haskell-Typen und -Funktionen ab. Weiterhin bietet KiCS2 dem Programmierer die Möglichkeit Curry-Funktionen extern, also durch Angabe einer Haskell-Implementierung, zu definieren. Weite Teile dieser Arbeit wurden auf diese Weise in Haskell implementiert.
\\
Zur Realisierung der Modellierungskomponente wird KiCS2 zunächst um eine Bibliothek für Finite Domain Constraints erweitert. Diese Constraints sollen dann später durch Anbindung der FD-Solver des Monadic Constraint Programming Frameworks an KiCS2 gelöst werden. Die Frage ist nun, wie man ein in Curry mit Hilfe der Finite Domain Bibliothek formuliertes Constraint-Problem in Haskell repräsentiert und diese Haskell-Repräsentation an den Solver übergibt.
\\
KiCS2 unterstützt bereits Gleichheitsconstraints der Form $e_{1} =:= e_{2}$, durch die ein Ausdruck $e_{1}$ mit einem $e_{2}$ unifiziert wird. Da es derartige Constraints in Haskell nicht gibt, wird die Haskelldarstellung eines jeden Curry-Datentyps in KiCS2, um einen sogenannten \lstinline|Guard|-Konstruktor erweitert, mit dem man die Möglichkeit hat, Werte durch Constraints zu beschränken. Allgemein hat ein solcher Guard-Ausdruck die folgende Form \lstinline|Guard cs e|. Hierbei ist \lstinline|e| ein Wert eines bestimmten Curry-Datentyps und \lstinline|cs| die Haskell-Darstellung der Curry-Constraints, durch die \lstinline|e| beschränkt wird. Somit ist ein Ausdruck der Form \lstinline|Guard cs e| so zu interpretieren, dass der Wert \lstinline|e| nur dann gültig ist, wenn die Constraints \lstinline|cs| erfüllbar sind. Bei der Auswertung eines \lstinline|Guard|-Ausdrucks wird also ebenfalls eine Lösungskomponente aufgerufen, die die Erfüllbarkeit der Constraints prüft. (Weitere Details und Beispiele zur Implementierung des Gleichheitsconstraints sowie zur Auswertung in KiCS2 findet man im entsprechenden Grundlagen-Kapitel \textcolor{red}{$<$hier verlinken$>$}).
\\
Die Idee ist nun, dass man auch für die Finite Domain Constraints der Curry-Bibliothek eine entsprechende Darstellung in Haskell definiert und diese Haskell-Repräsentationen der Constraints mit Hilfe des \lstinline|Guard|-Konstrukts nach dem gleichen Schema durch die Implementierung durchreicht, wie dies auch mit den bisherigen Curry-Constraints geschieht. Bei Aufruf einer Constraint-Funktion aus der Bibliothek, soll also in Haskell ein \lstinline|Guard|-Ausdruck passenden Typs, der die zugehörige Haskell-Darstellung des Constraints enthält, erzeugt werden. Da die Constraints eines Modells dem Solver nicht einzeln übergeben werden sollen, werden vor der Auswertung alle erzeugten \lstinline|Guard|-Ausdrücke zu einem einzigen \lstinline|Guard|-Ausdruck zusammengefasst, der eine Liste aller Haskell-Constraints enthält. Bei der Auswertung eines solchen \lstinline|Guard|-Ausdrucks durch KiCS2 werden schließlich alle Haskell-Constraints in dieser Liste in Constraints der Modellierungssprache des Monadic Constraint Programming Frameworks übersetzt und das resultierende Modell durch den MCP-Solver gelöst. Die nachfolgende Grafik verdeutlicht diesen Vorgang nochmals.
\\
\textcolor{red}{$<$hier Zeichnung einfügen$>$})
\\
\\

\clearpage

\section{Implementierung}
\label{chapter_implementation}
Die ausführliche Beschreibung der Implementierung in diesem Kapitel folgt genau dem Vorgehen bei der Entwicklung der generischen Constraint-Solver Schnittstellen für KiCS2. Das heißt, der erste Teilabschnitt beschreibt die Erweiterung von KiCS2 um eine Bibliothek für Finite Domain Constraints, wie man diese Constraints in Haskell repräsentiert und wie man sie mit den bereits vorhandenen Gleichheitsconstraints kombinieren kann.
\\
Der zweite Unterabschnitt behandelt dann ausführlich das Vorgehen zum Anschluss der Constraint-Solver des Monadic Constraint Programming Frameworks. Es wird unter anderem erklärt, wie die FD-Constraints in die MCP-Modellierungssprache übersetzt werden, wie daraus dann ein spezielles MCP-(Baum-)Modell für einen konkreten Solver generiert wird und wie die vom Solver gefundenen Lösungen in KiCS2 ausgegeben werden können.
\\
Im letzten Abschnitt des Implementierungskapitels wird schließlich von der speziellen Finite Domain Constraint Implementierung abstrahiert, indem zunächst die wichtigsten Ideen und Konzepte aus dieser konkreten Realisierung abgeleitet und diese dann zur Entwicklung generischer Schnittstellen zur Integration beliebiger Constraint-Solver verwendet werden. Abschließend wird gezeigt, wie man die bisherige Integration der FD-Constraints und der MCP-Solver auch über das generische Interface an KiCS2 anschließen kann.

\subsection{Entwicklung einer Finite Domain Constraint Bibliothek für KiCS2}
Dieser Abschnitt befasst sich mit der Entwicklung einer Finite Domain Constraint Bibliothek für KiCS2. Zunächst werden die von der Bibliothek bereitgestellten Constraint-Funktionen vorgestellt, dann wird auf ihre externe Implementierung in Haskell eingegangen. Abschließend wird erklärt, wie man die Finite Domain Constraints dieser Bibliothek mit dem Curry-Gleichheitsconstraint bei der Modellierung von Constraint-Problemen kombinieren kann.

\subsubsection{KiCS2 CLPFD Bibliothek}
Die im folgenden vorgestellte Finite Domain Constraint Bibliothek für KiCS2 (CLPFD-Bibliothek) orientiert sich stark an der entsprechenden Bibliothek des PAKCS-Curry-Compilers. Sie definiert die folgenden Funktionen:
\begin{lstlisting}[language=Haskell,caption=CLPFD-Bibliothek]
(+#),(-#),(*#)   :: Int -> Int -> Int
(=#),(/=#),(<#),
(<=#),(>#),(>=#) :: Int -> Int -> Success
domain           :: [Int] -> Int -> Int -> Success
allDifferent     :: [Int] -> Success
sum              :: [Int] -> Int
genVars          :: Int -> [Int]
labeling         :: [Int] -> Success
labelingWith     :: LabelingStrategy -> [Int] -> Success
\end{lstlisting}
Wie man sieht, sind die Constraints über einem \lstinline|Int|-Wertebereich definiert und verwenden mit Ausnahme der arithmetischen Operationen den speziell für Constraints in Curry eingeführten Typ \lstinline|Success| für den Rückgabewert. Auf diese Weise können bei der Modellierung eines Problems mehrere Constraints über den vordefinierten Konkatenationsoperator \lstinline|(&)| verknüpft werden. Neben den bekannten arithmetischen Operationen und den relationalen Vergleichsoperatoren, stellt die CLPFD-Bibliothek noch einige Hilfsfunktionen und komplexere Constraints zur Verfügung:
\begin{itemize}
\item Mit \lstinline|domain vs min max| beschränkt man alle Finite Domain Variablen in der List \lstinline|vs| auf den Wertebereich gegeben durch ein minimal möglichen Wert \lstinline|min| und einen maximal möglichen Wert \lstinline|max|.
\item Das Constraint \lstinline|allDifferent vs| erzwingt, dass die Werte der Constraint-Variablen in der Liste \lstinline|vs| paarweise verschieden sind.
\item \lstinline|sum vs| liefert die Summe der Werte aller Constraint-Variablen in der Liste \lstinline|vs|.
\item Mit \lstinline|genVars n| kann man eine Liste von \lstinline|n| neuen Constraint-Variablen erzeugen.
\item Durch \lstinline|labeling vs| kann man angeben, dass das Labeling, also das Ausprobieren von Variablenbelegungen gemäß gültigem Wertebereich, über allen Constraint-Variablen in der Liste \lstinline|vs| durchgeführt werden soll. Während bei der einfachen \lstinline|labeling|-Funktion das Labeling der Variablen in der gegebenen Reihenfolge durchgeführt wird, kann man der Funktion \lstinline|labelingWith| zusätzlich eine Labeling-Strategie übergeben. Die CLPFD-Bibliothek unterstützt bislang die folgenden vier Strategien:
\begin{itemize}
\item \lstinline|InOrder|: Labeling in der ursprünglichen Reihenfolge
\item \lstinline|FirstFail|: Beim Labeling wird die Constraint-Variable mit dem kleinsten (dem am weitesten eingeschränkten) Wertebereich bevorzugt.
\item \lstinline|MiddleOut|: Beginnt die Belegung der Constraint-Variablen beim Labeling mit Werten aus "der Mitte" des Wertebereichs.
\item \lstinline|EndsOut|: Beginnt die Belegung der Constraint-Variablen beim Labeling mit den "äußersten" Werten (also abwechselnd mit den größten und kleinsten Werten) des Wertebereichs.
\end{itemize}
\end{itemize}
Bis auf \lstinline|genVars| und \lstinline|labeling| werden alle Funktionen der CLPFD-Bibliothek extern implementiert. Das bedeutet, die eigentliche Definition dieser Funktionen erfolgt nicht in Curry sondern in Haskell. Dazu werden die entsprechenden Funktionen im Curry-Code mit dem Schlüsselwort \lstinline|external| gekennzeichnet. Die Implementierung der so deklarierten Funktionen in Haskell erfolgt dann in einer Datei \emph{External\_\textless Curry-Modulname\textgreater.hs} im gleichen Verzeichnis. Die vom Programmierer implementierten Haskell-Definition aus diesem Modul werden vom KiCS2-Compiler letztendlich an den bei der Übersetzung generierten Haskell-Code angehangen.
\\
Im Folgenden soll die Curry-Implementierung der Funktionen \lstinline|(+#)| und \lstinline|domain| beispielhaft näher betrachtet werden.
\begin{lstlisting}[language=Haskell,caption=Addition auf FD-Termen (Curry)]
(+#) :: Int -> Int -> Int
x +# y = ((prim_FD_plus $!! x) $!! y)

prim_FD_plus :: Int -> Int -> Int
prim_FD_plus external
\end{lstlisting}
Die Addition zweier FD-Constraint-Terme wird durch die externe Funktion \lstinline|prim_FD_plus| realisiert. Der \lstinline|($!!)|-Operator sorgt dafür, dass die beiden Argumente \lstinline|x| und \lstinline|y| strikt zur Normalform ausgewertet werden, bevor \lstinline|prim_FD_plus| auf sie angewandt wird. Durch diese strikte Auswertung müssen später bei der externen Implementierung von \lstinline|prim_FD_plus| beim Pattern Matching weniger Fälle betrachtet werden (siehe unten).
\par
Bei Constraint-Funktionen mit Listenargumenten, wie beispielsweise \lstinline|domain| wird durch Aufruf der in der \emph{Curry-Prelude} definierten Hilfsfunktion \lstinline|ensureSpine| zunächst überprüft, ob die übergebene Liste in eine sogenannte \emph{spine}-Form überführbar ist. Dabei wird sichergestellt, dass die Liste endlich ist und keine freien Variablen als Teillisten enthält. Die Listenelemente werden bei diesem Vorgehen zunächst nicht weiter betrachtet. Bevor jedoch \lstinline|prim_domain| angewandt wird, werden sie mit Hilfe des \lstinline|($!!)|-Operators genauso zur Normalform ausgewertet wie die Variablen für die untere und obere Begrenzung des Wertebereichs:
\begin{lstlisting}[language=Haskell,caption=Domain-Constraint (Curry)]
domain :: [Int] -> Int -> Int -> Success
domain vs l u = ((prim_domain $!! (ensureSpine vs)) $!! l) $!! u

prim_domain :: [Int] -> Int -> Int -> Success
prim_domain external

ensureSpine :: [a] -> [a]
ensureSpine l = ensureList (ensureNotFree l)
 where ensureList []     = []
       ensureList (x:xs) = x : ensureSpine xs
\end{lstlisting}
Die übrigen Funktionen der Bibliothek werden nach dem gleichen Prinzip implementiert. Das heißt, die Argumente der Constraint-Funktionen werden normalisiert, bevor sie an die jeweilige extern implementierte Funktion übergeben werden. Bei Listenargumente wird zusätzlich die Überführbarkeit in die \emph{spine}-Form überprüft.
\par
Ein Anwendungsbeispiel für Finite Domain Constraints ist das N-Damen-Problem. Dabei ist es das Ziel, N-Damen auf einem NxN-Schachbrett so zu platzieren, dass keine Dame eine andere Dame schlagen kann. Hierbei gelten die vom Schach bekannten Züge für eine Dame. Es darf also keine Damen mit einer anderen Damen in derselben Spalte, Reihe oder Diagonale des Schachbretts stehen.
\\
Mit den FD-Constraints der CLPFD-Bibliothek lässt sich nun beispielsweise das 4-Damen-Problem folgendermaßen modellieren:
\begin{lstlisting}[language=Haskell,caption=Beipiel: 4-Damen-Problem]
fourQueens = let queens = [q1,q2,q3,q4]
             in domain queens 1 4 &
                all_safe queens &
                labeling queens
 where q1,q2,q3,q4 free 

all_safe [] = success
all_safe (q:qs) = safe q qs 1 & all_safe qs

safe :: Int -> [Int] -> Int -> Success
safe _ [] _ = success
safe q (q1:qs) p = no_attack q q1 p & safe q qs (p+#1)

no_attack q1 q2 p = q1 /=# q2 & q1 /=# q2+#p & q1 /=# q2-#p
\end{lstlisting}
\textcolor{red}{$<$hier Zeichnung einfügen$>$})
\\
\\
Die Tatsache, dass jede Dame in einer anderen Spalte des Schachbretts positioniert werden soll, wird direkt durch die vier freien Variablen \lstinline|q1,q2,q3,q4| modelliert. Der Wertebereich dieser Variablen wird auf ${1,2,3,4}$ festgelegt. Eine solche Variable gibt dann zusammen mit ihrem Wert genau ein Feld auf dem Schachbrett an. Die Variable selbst bestimmt die Spalte, ihr Wert die Reihe (vergleiche Zeichnung), das heißt \lstinline|q1 = 2| bedeutet, platziere eine Dame in der 1. Spalte des Schachbretts und zwar auf dem Feld in der 2. Reihe.
Bei der Modellierung des 4-Damen-Problems werden neben dem \lstinline|domain|- und \lstinline|labeling|-Constraint aus der CLPFD-Bibliothek auch noch einige Hilfsconstraints verwendet: Die Funktion \lstinline|no_attack| erzeugt für zwei übergebene Damen alle Constraints, die nötig sind, um sicherzustellen, dass diese sich nicht gegenseitig schlagen können (\lstinline|q1 /=# q2|  $\Rightarrow$ Damen stehen nicht in der Gleichen Reihe, \lstinline|q1 /=# q2+#p & q1 /=# q2-#p| $\Rightarrow$ Damen stehen nicht auf der gleichen aufsteigenden bzw. abfallenden Diagonalen).
\\
\lstinline|safe| überprüft durch Aufruf von \lstinline|no_attack|, dass eine übergebene Damen-Position \lstinline|q| sicher ist, also von keiner der anderen Damen angegriffen werden kann und \lstinline|all_safe| wendet dieses \lstinline|safe|-Constraint schließlich auf alle vier Damen an.
\subsubsection{Darstellung der Constraints in Haskell}
Nachdem KiCS2 nun um eine Bibliothek für Finite Domain Constraints erweitert wurde, beschreibt der folgende Abschnitt die Implementierung der externen Funktionen, mit deren Hilfe diese Bibliothek realisiert wird.
\\
Zur Erinnerung die grundlegende Idee ist es, jeden Aufruf einer Constraint-Funktion aus der CLPFD-Bibliothek in Curry auf einen \lstinline|Guard|-Ausdruck mit dem entsprechenden Constraint in Haskell abzubilden. Bevor nun eine hierfür geeignete Haskell-Repräsentation von Finite Domain Constraints definiert wird, soll aber zunächst eine Darstellung für FD-Terme in Haskell eingeführt werden.
\par
Finite Domain Constraints werden üblicherweise über Termen eines bestimmten Typs definiert. Dieser Typ wird durch den Wertebereich, über dem die Constraint-Variablen definiert werden, vorgegeben. In der Regel verwendet man boolesche oder Integer-Terme. Neben Constraint-Variablen zählen auch Konstanten zu den Basistermen. Durch die Zusammenfassung in Listen oder Anwendung arithmetischer Operationen können aus solchen (Basis-)Termen komplexere Termausdrücke konstruiert werden.
\\
Da die Constraints der CLPFD-Bibliothek über einer \lstinline|Int|-Domain definiert wurden, ist nun also ein Typ zur Repräsentation von Integer-FD-Termen in Haskell gesucht. Hierfür wird die folgende polymorphe Datenstruktur eingeführt:
\begin{lstlisting}[language=Haskell,caption=Repräsentation von FD-Termen (Haskell)]
data FDTerm a = Const a
              | FDVar ID
\end{lstlisting}
Ein Wert vom Typ \lstinline|FDTerm a| ist nun entweder eine Konstante mit einem Wert vom Typ \lstinline|a| oder eine FD-Variable. Zur Identifikation einer FD-Variablen wird der Typ \lstinline|ID| wiederverwendet. KiCS2 benutzt diesen \lstinline|ID|-Typ zur eindeutigen Identifikation von \lstinline|Choices|, mit deren Hilfe unter anderem die freien Variablen aus Curry in Haskell repräsentiert werden. Die Wiederverwendung dieses Typs erleichtert später die Zuordnung von freien Variablen in einem Curry-Constraint-Modell zu deren FD-Variablen-Repräsentation im entsprechenden Haskell-Modell.
\par
Nun da man mit dem Typ \lstinline|FDTerm Int| Integer-FD-Terme in Haskell repräsentieren kann, ist es möglich eine Datenstruktur in Haskell zu definieren, mit deren Hilfe man die Constraints aus der CLPFD-Bibliothek in Haskell darstellen kann:
\begin{lstlisting}[language=Haskell,caption=Repräsentation von FD-Constraints (Haskell)]
data FDConstraint 
  = FDRel RelOp (FDTerm Int) (FDTerm Int)
  | FDArith ArithOp (FDTerm Int) (FDTerm Int) (FDTerm Int)
  | FDSum [FDTerm Int] (FDTerm Int)
  | FDAllDifferent [FDTerm Int]
  | FDDomain [FDTerm Int] (FDTerm Int) (FDTerm Int)
  | FDLabeling LabelingStrategy [FDTerm Int]

data ArithOp = Plus | Minus | Mult
data RelOp   = Equal | Diff | Less
\end{lstlisting}
Wie man sehen kann, besitzt der Datentyp \lstinline|FDConstraint| für jede Constraint-Funktion der oben vorgestellten Bibliothek einen dazu passenden Konstruktor wie beispielsweise \lstinline|FDDomain| für die \lstinline|domain|-Funktion. Analog zu den \lstinline|Int| und \lstinline|[Int]|-Argumenten der CLPFD-Bibliothek erhalten diese Konstruktoren Integer-FD-Terme und/oder Listen solcher Terme als Argumente. 
\\
Die relationalen Vergleichsoperatoren wie \lstinline|(=#)|, \lstinline|(/=#)| usw. werden durch einen \lstinline|FDRel|-Konstruktorterm mit passendem \lstinline|RelOp|-Wert dargestellt. Für einige Vergleichsoperatoren wie \lstinline|(<=#)|,\lstinline|(>#)| und \lstinline|(>=#)| gibt es nicht extra einen \lstinline|RelOp|-Wert, da sich diese Fälle auch mit Hilfe von \lstinline|Less| und \lstinline|Equal| ausdrücken lassen. Nach dem gleichen Prinzip werden die Addition, Subtraktion und Multiplikation auf FD-Termen durch \lstinline|FDArith|-Konstruktorterme mit dem entsprechenden arithmetischen Operator \lstinline|ArithOp| repräsentiert.
\\
Einige Konstruktoren wie \lstinline|FDArith| oder \lstinline|FDSum| erhalten mehr Argumente als ihre zugehörige Funktion in der CLPFD-Bibliothek. Dies hängt damit zusammen, dass komplexe arithmetische Ausdrücke in der Haskell-Darstellung flachgeklopft werden sollen. Betrachtet man beispielsweise den folgenden Curry-Ausdruck \lstinline|(x +# 7) *# 2 where x free|, so kann dieser durch Einführung von Hilfsvariablen, an die die (Zwischen-)Ergebnisse der einzelnen arithmetischen Operationen gebunden werden, wie folgt flachgeklopft werden: \lstinline|y = x +# 7|, \lstinline|z = y *# 2|. Der Konstruktor \lstinline|FDArith| drückt nun genau dies aus: Er erhält als drittes Argument eine neue FD-Variable, an die das Ergebnis des arithmetischen Ausdrucks gebunden wird. Somit wird der Beispielausdruck durch die beiden folgenden \lstinline|FDConstraint|-Konstruktorterme in Haskell abgebildet:
\begin{lstlisting}[language=Haskell]
FDArith Plus (FDVar <id_x>) (Const 7) (FDVar <id_y>)
FDArith Mult (FDVar <id_y>) (Const 2) (FDVar <id_z>)
\end{lstlisting}
Für das Summen-Constraint - in Haskell dargestellt durch den \lstinline|FDSum|-Konstruktor - gilt dies genauso.
\par
Bevor man nun mit Hilfe des \lstinline|FDConstraint|-Datentyps die externen Funktionen der CLPFD-Bibliothek implementieren kann, sind noch zwei Dinge notwendig: Zum einen muss der Constraint-Typ von KiCS2, der in den \lstinline|Guard|-Ausdrücken verwendet wird, derart erweitert werden, dass auch Constraints vom Typ \lstinline|FDConstraint| unterstützt werden.
\\
Zum anderen benötigt man Funktionen, mit denen man die Haskell-Repräsentation eines Curry-Int (\lstinline|C_Int|) bzw. einer Curry-Int-Liste \lstinline|OP_List C_Int| in einen Integer-FD-Term bzw. eine Liste von Integer-FD-Termen umwandeln kann.
\\
Die Erweiterung des Constraint-Typs zur Unterstützung von Constraints vom Typ \lstinline|FDConstraint| lässt sich relativ einfach umsetzen. Man erweitert einfach den in KiCS2-\lstinline|Guard|-Ausdrücken verwendeten \lstinline|Constraints|-Typ (siehe auch Grundlagen-Kapitel \textcolor{red}{$<$hier Verweis auf KiCS2 Grundlagen Unifikation??$>$})) um einen Konstruktor für Finite Domain Constraints:
\begin{lstlisting}[language=Haskell,caption=Erweiterung des Datentyps Constraints]
data Constraints
  = ...
  | FDConstr [FDConstraint]
\end{lstlisting}
Man verwendet eine Liste vom Typ \lstinline|FDConstraint| damit auch mehr als ein FD-Constraint in einem \lstinline|Guard|-Ausdruck durch die Implementierung gereicht werden. Das Ziel soll es später sein, die FD-Constraints aus verschiedenen \lstinline|Guard|-Ausdrücken in einem einzelnen solchen Ausdruck zu sammeln, bevor ein geeigneter Solver aufgerufen wird.
\par
Für die Definition einer Funktion \lstinline|toFDTerm :: C_Int -> FDTerm Int| zur Transformation der Haskell-Darstellung eines Curry-Ints in einen FD-Term soll zunächst der Ausgangstyp \lstinline|C_Int| näher betrachtet werden:
\begin{lstlisting}[language=Haskell,caption=Repräsentation vom Curry-Typ 'Int' in Haskell]
data C_Int
     = C_Int Int#
     | C_CurryInt BinInt
     | Choice_C_Int ID C_Int C_Int
     | Choices_C_Int ID ([C_Int])
     | Fail_C_Int
     | Guard_C_Int Constraints C_Int
\end{lstlisting}
Mit den beiden ersten Konstruktoren kann man konstante Integerwerte einführen und zwar einmal über unboxed Ints (Konstruktor \lstinline|C_Int|) und einmal über eine binäre Codierung mit \lstinline|Nat|-Werten (Konstruktor \lstinline|C_CurryInt|). Die übrigen Konstruktoren tauchen mit entsprechend angepasstem Namen bei jeder Datentypdefinition eines Curry-Typs in Haskell auf (vergleiche Typ \lstinline|C_Bool| im Grundlagenkapitel über KiCS2). Sie dienen zur Darstellung des Nicht-Determinismus (\lstinline|Choice_C_Int| und \lstinline|Choices_C_Int|), zur Repräsentation einer fehlgeschlagenen Berechnung \lstinline|Fail_C_Int| sowie dem Hinzufügen von Constraints \lstinline|Guard_C_Int| in der Haskell-Übersetzung eines Curry-Ausdrucks vom Typ \lstinline|Int|.
\\
Bei der Implementierung der Übersetzungsfunktion \lstinline|toFDTerm| wird nun allerdings nicht auf alle diese Fälle gematcht. Da die Argumente der Constraint-Funktionen normalisiert werden, bevor sie an die zugehörige externe Constraint-Funktion übergeben werden (siehe Erklärung des \lstinline|($!!)|-Operators weiter oben), wird davon ausgegangen, dass bei Aufruf von \lstinline|toFDTerm|, dass Argument bereits in Normalform ist. Somit wird das Pattern Matching bei der Implementierung von \lstinline|toFDTerm| nur für die Konstruktoren einer Integer-Konstanten bzw. einer -Variable durchgeführt:
\begin{lstlisting}[language=Haskell,caption=Umwandlung von Curry-FD-Termen in Haskell-FD-Terme]
toFDTerm :: C_Int -> FDTerm Int
toFDTerm (Choices_C_Int (FreeID i) _) = FDVar i
toFDTerm x                            = Const (fromCurry x)
\end{lstlisting}
Eine freie Integer-Variable - in Haskell repräsentiert durch den Konstruktor \lstinline|Choices_C_Int| mit einer \lstinline|FreeID| als ID-Argument - wird in eine neue FD-Variable mit der gleichen ID \lstinline|i| transformiert. In allen übrigen Fällen muss es sich bei dem Argument gemäß der obigen Annahme um eine Integerkonstante handeln und somit wird ein konstanter FD-Term mit dem entsprechenden Integer-Wert eingeführt. Dazu wird die überladene Hilfsfunktion \lstinline|fromCurry| verwendet, die die Haskell-Darstellung eines Curry-Typs in den zugehörigen Haskell-Typ konvertiert. Beispielsweise ist \lstinline|fromCurry| auf dem Typ \lstinline|C_Bool| folgendermaßen definiert:
\begin{lstlisting}[language=Haskell,caption=Beispiel: fromCurry für C\_Bool]
fromCurry C_True  = True
fromCurry C_False = False
\end{lstlisting}
Bei der Implementierung von \lstinline|toFDTerm| wird \lstinline|fromCurry| benutzt, um einen Wert vom Typ \lstinline|C_Int| in einen entsprechenden Wert vom Haskell-Typ \lstinline|Int| zu überführen.
\par
Nun fehlt noch eine Funktion, mit der man eine Liste von Integern in Curry (\lstinline|OP_List C_Int|) in eine Liste von FD-Termen in Haskell (\lstinline|[FDTerm Int]|) übersetzen kann. Zunächst betrachtet man den polymorphen Typ, mit dem Curry-Listen in Haskell repräsentiert werden:
\begin{lstlisting}[language=Haskell,caption=Repräsentation vom Curry-Typ '[a]' in Haskell]
data OP_List a
     = OP_List
     | OP_Cons a (OP_List a)
     | Choice_OP_List ID (OP_List a) (OP_List a)
     | Choices_OP_List ID ([OP_List a])
     | Fail_OP_List
     | Guard_OP_List Constraints (OP_List a)
\end{lstlisting}
Dabei ist \lstinline|OP_List| der Konstruktor für eine leere Liste und \lstinline|OP_Cons| der Konstruktor um ein neues Element vom Typ \lstinline|a| vor eine Liste vom Typ \lstinline|OP_List a| zu hängen. Man definiert nun eine Übersetzungsfunktion \lstinline|toFDList| wie folgt:
\begin{lstlisting}[language=Haskell,caption=Umwandlung von Curry-FD-Listen in Haskell-FD-Listen]
toFDList :: OP_List C_Int -> [FDTerm Int]
toFDList OP_List        = []
toFDList (OP_Cons x xs) = toFDTerm x : toFDList xs
\end{lstlisting}
Eine leere Curry-Liste wird in eine leere Haskell-Liste überführt. Bei einer nicht-leeren Liste wird das aktuelle Listenelement per \lstinline|toFDTerm| in einen FD-Term transformiert und per Haskell-Cons-Operator vor die durch rekursiven Aufruf von \lstinline|toFDList| übersetzte Restliste gehangen.
\par
Nun ist man in der Lage die Funktionen der CLPFD-Bibliothek extern zu implementieren. Beispielhaft betrachtet wird zunächst die Implementierung der Additionsfunktion \lstinline|prim_FD_plus| aus dem Curry-Model \emph{CLPFD.curry}. 
\\
Wie bereits erwähnt, erfolgt die externe Implementierung dieser Funktion nun in einem Modul \emph{External\_CLPFD.hs}. In diesem Haskell-Modul müssen nun Regeln für eine Funktion \lstinline|external_d_C_prim_FD_plus| angegeben werden. Durch den Präfix \lstinline|external_d_C_| werden alle deterministischen externen Funktionen in KiCS2 gekennzeichnet. Für nicht-deterministische Funktionen wird entsprechend der Präfix \lstinline|external_nd_C_| verwendet. Eine Funktion in KiCS2 gilt als nicht-deterministisch, wenn sie nicht-deterministische Werte, also z.B. neue freie Variablen einführt. Dazu erhalten nicht-deterministische Funktion durch ein zusätzliches \lstinline|IDSupply|-Argument einen quasi unendlichen Vorrat unbenutzter \lstinline|ID|s. Der Programmierer sollte allerdings vermeiden nicht-deterministische Funktionen einzuführen, da \textcolor{red}{$<$hier Begründung ergänzen$>$}))
\\
Wie weiter oben beschrieben, sollen arithmetische Ausdrücke flachgeklopft werden. Das heißt, jedes Zwischenergebnis einer einfachen arithmetischen Operation soll an eine neue Constraint-Variable gebunden werden. Zur Erzeugung einer neuen Constraint-Variablen wird allerdings eine unverbrauchte \lstinline|ID| benötigt, welche man beispielsweise durch Einführung einer neuen Curry-Variablen erhält. Man könnte \lstinline|prim_FD_plus| nun wie zuvor beschrieben mit Hilfe einer nicht-deterministische externen Funktion implementieren, die über ihren \lstinline|IDSupply| neue freie Variablen zur Verfügung stellt. Durch eine kleine Anpassung der Curry-Implementierung muss sich der Programmierer aber gar nicht selbst um die Erzeugung dieser freien Variablen in Haskell kümmern:
\begin{lstlisting}[language=Haskell,caption=Addition auf FD-Termen (Curry) - erweitert]
(+#) :: Int -> Int -> Int
x +# y = ((prim_FD_plus $!! x) $!! y) result where result free

prim_FD_plus :: Int -> Int -> Int -> Int
prim_FD_plus external
\end{lstlisting}
Man übergibt einer Funktion wie \lstinline|prim_FD_plus| einfach eine freie Variable namens \lstinline|result| als zusätzliches Argument. An diese freie Variable soll dann später das Ergebnis der Addition gebunden werden. Auf diese Weise wird die Einführung des Nicht-Determinismus auf die Ebene der \lstinline|(+#)|-Funktion verschoben. Bei der Übersetzung dieser Funktion sorgt KiCS2 nun selbst für die Erzeugung einer neuen freien Variable, so dass sich der Programmierer darum nicht mehr kümmern muss.
\\
Nach dem gleichen Prinzip wird auch der Code für die anderen arithmetischen Constraint-Funktionen (u.a. \lstinline|sum|) in Curry angepasst.
\\
Nach diesen Anpassungen kann man \lstinline|external_d_C_prim_FD_plus| nun folgendermaßen definieren:
\begin{lstlisting}[language=Haskell,caption=Addition auf FD-Termen (Haskell)]
external_d_C_prim_FD_plus :: C_Int -> C_Int -> C_Int 
                          -> ConstStore -> C_Int
external_d_C_prim_FD_plus x y result _ = 
  let c = [newArithConstr Plus x y result]
  in Guard_C_Int (FDConstr c) result

newArithConstr :: ArithOp -> C_Int -> C_Int -> C_Int 
               -> FDConstraint
newArithConstr constr x y result = 
  FDArith constr (toFDTerm x) (toFDTerm y) (toFDTerm result)
\end{lstlisting}
Wie man sieht, werden die Curry-Int-Argumente bei der Implementierung einer externen Funktion nun durch ihre entsprechende Haskell-Darstellung (also hier \lstinline|C_Int|-Argumente) ersetzt. Außerdem wird als zusätzliches Argument ein sogenannter \lstinline|ConstStore| übergeben. Dieser ConstStore ist eine Optimierung für den Zugriff auf Currys Bindungsconstraints und spielt keine Rolle für die hier vorgestellte Implementierung der FD-Constraint-Bibliothek. Daher wird dieses Argument nur bei Aufruf von Hilfsfunktionen aus der \emph{Curry-Prelude} durchgereicht (siehe unten) und ansonsten durch Verwendung von \lstinline|_| ignoriert.
\\
Zur Implementierung der arithmetischen Operationen wird eine Hilfsfunktion namens \lstinline|newArithConstr| definiert. Diese erzeugt für den jeweils übergebenen arithmetischen Operator und dessen Argumente einen passenden \lstinline|FDArith|-Konstruktorterm, indem die Argumente mittels \lstinline|toFDTerm| in Integer-FD-Terme übersetzt werden. 
\\
Die Funktion \lstinline|external_d_C_prim_FD_plus| erzeugt durch Aufruf von \lstinline|newArithConstr| ein Additionsconstraint, das die Summe der FD-Terme von \lstinline|x| und \lstinline|y| an die FD-Term-Repräsentation von \lstinline|result| bindet. Mit Hilfe des weiter oben eingeführten \lstinline|FDConstr|-Konstruktor wird schließlich  wird ein neuer \lstinline|Guard|-Ausdruck konstruiert, welcher die freie Variable \lstinline|result| vom Typ \lstinline|C_Int| mit dem zuvor erzeugten Additionsconstraint beschränkt.
\\
Der erzeugte \lstinline|Guard|-Ausdruck ist nun also so zu interpretieren, dass die freie Variable für das Ergebnis der Addition, \lstinline|result|, erst dann ausgewertet werden kann, wenn das sie beschränkende Additionsconstraint gelöst wurde. Die übrigen arithmetischen Operatoren sowie das Summenconstraint werden nach dem gleichen Prinzip realisiert.
\par
Als weiteres Beispiel soll die externe Implementierung von \lstinline|prim_FD_equal| betrachtet werden:
\begin{lstlisting}[language=Haskell,caption=Gleichheit auf FD-Termen (Haskell)]
external_d_C_prim_FD_equal :: C_Int -> C_Int -> ConstStore 
                           -> C_Success
external_d_C_prim_FD_equal x y _ = 
  let c = [newRelConstr Equal x y]
  in Guard_C_Success (FDConstr c) C_Success

newRelConstr :: RelOp -> C_Int -> C_Int -> FDConstraint
newRelConstr relOp x y = FDRel relOp (toFDTerm x) (toFDTerm y)
\end{lstlisting}
Analog zur Funktion \lstinline|newArithConstr| definiert man eine Hilfsfunktion \lstinline|newRelConstr|, welche für den übergebenen relationalen Operator und dessen Argumente ein passendes \lstinline|FDRel|-Constraint erzeugt. Durch Aufruf dieser Hilfsfunktion führt \lstinline|external_d_C_prim_FD_equal| dann ein Gleichheitsconstraint über den Argumenten \lstinline|x| und \lstinline|y| ein und konstruiert schließlich einen neuen \lstinline|Guard|-Ausdruck vom Typ \lstinline|C_Success|. Dieser \lstinline|Guard|-Ausdruck wird zu \lstinline|C_Success| reduziert, falls das Gleichheitsconstraint erfüllbar ist.
\par
Abschließend wird die externe Implementierung von \lstinline|prim_domain| beschrieben:
\begin{lstlisting}[language=Haskell,caption=Domain-Constraint (Haskell)]
external_d_C_prim_domain :: OP_List C_Int -> C_Int -> C_Int 
                         -> ConstStore -> C_Success
external_d_C_prim_domain vs l u _ = 
  let c = [FDDomain (toFDList vs) (toFDTerm l) (toFDTerm u)]
  in Guard_C_Success (FDConstr c) C_Success
\end{lstlisting}
Wie bei den zuvor vorgestellten Constraint-Funktionen, erzeugt auch \lstinline|external_d_C_prim_domain| zunächst eine passende Haskell-Repräsentation des Domain-Constraints in Form eines \lstinline|FDDomain|-Konstruktorterms, wobei die Argumente mittels \lstinline|toFDTerm| bzw. \lstinline|toFDList| in ihre Term- bzw. Term-Listen-Darstellung überführt werden. Anschließend verwendet man das erzeugte Wertebereichsconstraint zur Konstruktion eines \lstinline|Guard|-Ausdrucks.
\\
Nach diesem Schema werden auch die übrigen externen Constraint-Funktionen implementiert, so dass sie letztendlich alle einen \lstinline|Guard|-Ausdruck mit dem passenden \lstinline|FDConstraint| zurückliefern.
\par
Die bisherige Implementierung hat einen großen Nachteil: Auch für Constraint-Ausdrücke wie \lstinline|5 +# 7|, \lstinline|0 <# 2| oder \lstinline|allDifferent [1,2,3,2]| werden entsprechende \lstinline|Guard|-Ausdrücke generiert, obwohl man sie direkt berechnen und das Ergebnis zurückgeben könnte. Um diesen unnötigen Overhead zu vermeiden, soll eine zusätzliche Fallunterscheidung in alle extern implementierten Funktionen eingebaut werden: Sind alle Argumente einer solchen Funktion Konstanten, so ruft man eine passende Funktion aus der \emph{Curry-Prelude} auf, um den Constraint-Ausdruck direkt zu berechnen. Andernfalls wird, wie zuvor, ein passender \lstinline|Guard|-Ausdruck erzeugt.
\\
Da das Matching auf die verschiedenen Konstruktoren für konstante \lstinline|C_Int|-Wert recht umständlich wäre, wird eine neue Typklasse eingeführt, die einem hilft zu erkennen, ob ein Wert eines bestimmten Typs in Grundnormalform (ground normal form, kurz: GNF) ist:
\begin{lstlisting}[language=Haskell,caption=Typklasse GNFChecker]
class NonDet a => GNFChecker a where
  gnfCheck :: a -> Bool
  gnfCheck x = gnfCheck' (try x)
    where gnfCheck' (Val _) = True
          gnfCheck' _       = False
\end{lstlisting}
Diese Typklasse namens \lstinline|GNFChecker a| stellt ein Prädikat \lstinline|gnfCheck :: a -> Bool| zur Verfügung. Hierfür gibt es eine Default-Implementierung, die mit Hilfe der vordefinierten Funktion \lstinline|try :: NonDet a => a -> Try a| einen gegebenen Wert in eine generische \lstinline|Try|-Struktur überführt und dann durch Matching auf den Konstruktor \lstinline|Val| feststellt, ob es sich um einen konstanten Wert in GNF handelt oder nicht.
\\
Zur Anpassung der externen Implementierung der Constraint-Funktionen wird ein \lstinline|GNFChecker| für Integer- und einer für Listen-Argumente benötigt:
\begin{lstlisting}[language=Haskell,caption=GNFChecker-Instanzen]
instance GNFChecker C_Int

instance GNFChecker a => GNFChecker (OP_List a) where
  gnfCheck OP_List        = True
  gnfCheck (OP_Cons x xs) = gnfCheck x && gnfCheck xs
\end{lstlisting}
Für Integer-Werte kann die vordefinierte Default-Implementierung verwendet werden. Bei Listen muss hingegen nicht nur getestet werden, ob der oberste Listenkonstruktor konstant ist, sondern zusätzlich müssen auch alle Listenelemente in Grundnormalform sein. Das bedeutet man benötigt einen \lstinline|GNFChecker| für den Typ der Listenelemente. Dies wird durch ein entsprechendes Typklassenconstraint ausgedrückt.
\\
Schließlich wird die Default-Implementierung der Funktion \lstinline|gnfCheck| überschrieben: Bei einer leeren Liste (\lstinline|OP_List|) wird direkt \lstinline|True| zurückgegeben, sonst (\lstinline|OP_Cons|) werden nacheinander das aktuelle Listenelement und die Restliste getestet.
\\
Mit diesem Hilfsmittel lässt sich nun beispielsweise die externe Implementierung der Addition von FD-Termen folgendermaßen erweitern:
\begin{lstlisting}[language=Haskell,caption=Addition auf FD-Termen (Haskell) - erweitert]
external_d_C_prim_FD_plus :: C_Int -> C_Int -> C_Int 
                          -> ConstStore -> C_Int
external_d_C_prim_FD_plus x y result cs 
  | gnfCheck x && gnfCheck y = d_OP_plus x y cs
  | otherwise                = 
    let c = [newArithConstr Plus x y result]
    in Guard_C_Int (FDConstr c) result
\end{lstlisting}
Anstatt wie oben beschrieben direkt einen \lstinline|Guard|-Ausdruck zu erzeugen, wird nun überprüft, ob die beiden Argumente des Additionsconstraints \lstinline|x| und \lstinline|y| in GNF sind: Falls ja, so wird die von KiCS2 in Haskell generierte Funktion \lstinline|d_OP_plus| für die Curry-Addition von Integerwerten aus der \emph{Curry-Prelude} aufgerufen. Andernfalls wird, wie gehabt, ein \lstinline|Guard|-Ausdruck erzeugt.
\\
Für die übrigen Constraint-Funktionen wird nach dem gleichen Schema ebenfalls eine solche Fallunterscheidung eingebaut. Bei den relationalen Vergleichsoperatoren verwendet man zum Beispiel den entsprechenden booleschen Operator aus der \emph{Curry-Prelude} und gibt dann je nach dem booleschen Rückgabewert dieses Operators \lstinline|C_Success| oder \lstinline|Fail_C_Success| zurück.
\par
Zum Abschluss dieses Kapitels soll nun noch einmal ein Beispiel-Modell in Curry und dessen Repräsentation mit \lstinline|Guard|-Ausdrücken in Haskell betrachtet werden. Damit das Beispiel vor allem in der Haskell-Darstellung übersichtlich bleibt, betrachtet man dieses Mal das 2-Damen-Problem. Dieses lässt sich wie folgt mit der CLPFD-Bibliothek modellieren:
\begin{lstlisting}[language=Haskell,numbers=left,numberstyle=\tiny,caption=Beispiel: 2-Damen-Problem (Curry)]
twoQueens = 
  domain [q1,q2] 1 2 &  -- Festlegung des Wertebereichs
  q1 /=# q2 &           -- Reihen,
  q1 /=# q2 +# 1 &      -- aufsteigende Diagonalen und
  q1 /=# q2 -# 1 &      -- abfallende Diagonalen unterschiedlich
  labeling [q1,q2]      -- Labeling in gegebener Reihenfolge
 where q1,q2 free 
\end{lstlisting}
Dieses Mal wurde auf die Hilfsfunktionen verzichtet und alle erforderlichen Constraints aus der Bibliothek wurden explizit hingeschrieben. Auf diese Weise kann man leichter die Repräsentation des Modells in Curry mit der in Haskell vergleichen. In Haskell wird das obige Modell auf die unten angegebene Konjunktion von \lstinline|Guard|-Ausdrücken über \lstinline|FDConstraint|-Constraints abgebildet. Dabei handelt es sich um \lstinline|Guard|-Ausdrücke vom Typ \lstinline|C_Success|. Der Übersichtlichkeit halber wird unten auf den genauen Bezeichner für den Konstruktor verzichtet (\lstinline|Guard| statt \lstinline|Guard_C_Success|) und der \lstinline|FDConstr|-Wrapper um die Constraints vom Typ \lstinline|FDConstraint| wird ebenfalls weggelassen. Weiterhin wird angenommen, dass die \lstinline|ID| der freien Variablen \lstinline|q1| und \lstinline|q2| \lstinline|1| bzw. \lstinline|2| seien. Zusätzlich eingeführte Hilfsvariablen erhalten entsprechend fortlaufende \lstinline|ID|s, also \lstinline|3,4,...|):
\begin{lstlisting}[language=Haskell,basicstyle=\ttfamily\small,numbers=left,numberstyle=\tiny,caption=Beispiel: Guard-Ausdrücke für 2-Damen-Problem (Haskell)]
Guard [FDDomain [FDVar 1, FDVar 2] (Const 1) (Const 2)] C_Success &
Guard [FDRel Diff (FDVar 1) (FDVar 2)] C_Success &
Guard [FDArith Plus (FDVar 2) (Const 1) (FDVar 3)]
  Guard [FDRel Diff (FDVar 1) (FDVar 3)] C_Success &
Guard [FDArith Minus (FDVar 2) (Const 1) (FDVar 4)]
  Guard [FDRel Diff (FDVar 1) (FDVar 4)] C_Success &
Guard [FDLabeling InOrder [FDVar 1, FDVar 2]] C_Success
\end{lstlisting}
Wie man sieht, wird für jede der sieben im Modell verwendeten Constraint-Funktionen aus der CLPFD-Bibliothek (\lstinline|domain|, dreimal \lstinline|(/=#)|, \lstinline|(+)|, \lstinline|(-)| und \lstinline|labeling|) ein \lstinline|Guard|-Ausdruck mit dem entsprechenden \lstinline|FDConstraint|-Konstruktorterm erzeugt.
\\
Auffällig sind die verschachtelten \lstinline|Guard|-Ausdrücke in den Zeilen 3 und 4 sowie 5 und 6, die zur Abbildung der Constraint-Ausdrücke \lstinline|q1 /=# q2 +# 1| bzw. \lstinline|q1 /=# q2 -# 1| in Haskell konstruiert werden. Diese Verschachtelung resultiert aus der Anwendung des \lstinline|($!!)|-Operators bei der Implementierung von \lstinline|(/=#)|. 
\\
Zur Erinnerung: Dieser Operator sorgt dafür, dass die Argumente einer Funktion vor der Funktionsanwendung normalisiert werden. Somit wird unter anderem \lstinline|q2 +# 1| zur Normalform ausgewertet. Das bedeutet, es wird der \lstinline|Guard|-Ausdruck \lstinline|Guard_C_Int (FDConstr [FDArith Plus (FDVar 2) (Const 1) (FDVar 3)]) r| erzeugt, wobei \lstinline|3| die \lstinline|ID| der Hilfsvariable \lstinline|r| sei, an die das Ergebnis der Addition gebunden wird. Bei der Normalisierung wird dieser \lstinline|Guard|-Ausdruck vom Typ \lstinline|C_Int| nun allerdings auf die Ergebnisebene der Funktion \lstinline|(/=#)| propagiert. Das heißt, es wird ein \lstinline|Guard|-Ausdruck vom Typ \lstinline|C_Success| konstruiert, der das Ergebnis des Ausdrucks \lstinline|q1 /=# r| mit dem Additionsconstraint \lstinline|(FDConstr [FDArith Plus (FDVar 2) (Const 1) (FDVar 3)])| beschränkt. Durch Auswertung dieses Ungleichheitsconstraints erhält man letztendlich den inneren \lstinline|Guard|-Ausdruck. 
\begin{lstlisting}[language=Haskell,escapechar=§,caption=Beispiel: Auswertung zu Guard-Ausdrücken]
   q1 /=# q2 +# 1 
§$\rightarrow$§ (prim_FD_notequal $!! q1) $!! q2 +# 1
§$\rightarrow$§ (prim_FD_notequal $!! q1) $!! 
     (((prim_FD_plus $!! q2) $!! 1) result where result free)
...
§$\rightarrow$§ (prim_FD_notequal $!! q1) $!! 
     (Guard_C_Int (FDConstr 
       [FDArith Plus (FDVar 2) (Const 1) (FDVar 3)]) result)
§$\rightarrow$§ Guard_C_Success (FDConstr 
     [FDArith (FDVar 2) (Const 1) (FDVar 3)]) 
       ((prim_FD_notequal $!! q1) result)
...
§$\rightarrow$§ Guard_C_Success (FDConstr 
     [FDArith (FDVar 2) (Const 1) (FDVar 3)]) 
       (Guard_C_Success (FDConstr
         [FDRel Diff (FDVar 1) (FDVar 3)]) C_Success)
§$\rightarrow$§ Guard [FDArith Plus (FDVar 2) (Const 1) (FDVar 3)]
     Guard [FDRel Diff (FDVar 1) (FDVar 3)] C_Success
\end{lstlisting}

\subsubsection{Einsammeln aller Finite Domain Constraints}
Mit der bislang vorgestellten Erweiterung der KiCS2-Implementierung ist es möglich Finite Domain Constraints in Curry auf \lstinline|Guard|-Ausdrücke in Haskell abzubilden. Die Frage ist nun, wie man die Constraints, die mit diesen \lstinline|Guard|-Ausdrücken durch die Implementierung gereicht werden, letztendlich an einen Constraint-Solver weitergibt.
\\
Wie im Grundlagenkapitel über KiCS2 bereits erwähnt, liefert die Normalisierung eines Ausdrucks in KiCS2 entweder einen deterministischer Wert, der direkt ausgegeben werden kann, oder einen Suchbaum über nicht-deterministischen \lstinline|Choices|. Mit Hilfe von Suchalgorithmen kann ein solcher Baum nach weiteren (deterministischen) Ergebniswerten durchsucht werden. Auch die \lstinline|Guard|-Ausdrücke kommen als Knoten im Suchbaum vor. Bei der Auswertung eines solchen Knotens durch einen Suchalgorithmus wie die Tiefensuche werden die im \lstinline|Guard|-Ausdruck transportierten Constraints an einen Solver weitergegeben. Dieser Solver, der speziell zur Lösung der Curry-Bindungsconstraints entwickelt wurde, versucht die übergebenen Constraints zu lösen. Falls die Constraints erfüllbar sind, gibt der Solver zum einen eine Funktion zurück, mit der die beim Lösen getroffenen Bindungsentscheidungen zurückgesetzt werden können (\lstinline|reset|), zum anderen wird der Teil des Suchbaums zurückgegeben, in dem die Auswertung zunächst fortgesetzt werden soll (\lstinline|e'|). Ergibt die Prüfung des Solvers hingegen, dass die Constraints nicht lösbar sind, so wird die Auswertung in diesem Pfad des Baumes abgebrochen:
\begin{lstlisting}[language=Haskell]
...
dfsGuard cs e = solve cs e >>= \mbSltn -> case mbSltn of
  Nothing          -> mnil
  Just (reset, e') -> dfs cont e' |< reset
...
\end{lstlisting}
Die Idee ist nun, dass man die Implementierung der Suchalgorithmen um einen Fall für \lstinline|Guard|-Ausdrücke mit FD-Constraints erweitert. Stößt man während der Auswertung auf einen solchen Ausdruck, so soll ein geeigneter Finite Domain Solver aufgerufen werden, der die Constraints dieser \lstinline|Guard| löst und mögliche Lösungen in einer geeigneten Form zurückgibt, so dass die Auswertung darauf fortgesetzt werden kann:
\begin{lstlisting}[language=Haskell]
...
dfsGuard (FDConstr fdCs) e = let solutions = runFDSolver cs e
                             in dfs cont solutions
...
\end{lstlisting}
Ein Problem hierbei ist, dass ein \lstinline|Guard|-Ausdruck bislang nur ein einzelnes Finite Domain Constraint enthält. Zur Lösung eines Constraint-Problems benötigt ein Finite Domain Solver aber alle zur Modellierung des Problems verwendeten Constraints. Das bedeutet, man muss vor der KiCS2-Auswertung und damit auch vor dem Aufruf eines konkreten FD-Solvers, die FD-Constraints aus allen \lstinline|Guard|-Ausdrücken einsammeln und dann mit den gesammelten Constraints einen einzelnen neuen \lstinline|Guard|-Ausdruck konstruieren. Mit der Funktion \lstinline|searchFDCs| lässt sich dies erreichen: 
\begin{lstlisting}[language=Haskell,caption=Einsammeln der FD-Constraints]
searchFDCs :: NormalForm a => a -> [FDConstraint] -> a
searchFDCs x fdCs = 
  match sfChoice sfNarrowed choicesCons failCons sfGuard sfVal x
 where 
  sfChoice i x1 x2       = choiceCons i (searchFDCs x1 fdCs) 
                                        (searchFDCs x2 fdCs)
  sfNarrowed i xs        = choicesCons i 
                             (map (\x' -> searchFDCs x' fdCs) xs)
  sfGuard (FDConstr c) e = searchFDCs e (fdCs ++ c)
  sfGuard c e            = guardCons c (searchFDCs e fdCs)
  sfVal v | null fdCs    = v
          | otherwise    = guardCons (FDConstr fdCs) v
\end{lstlisting}
Bei der Implementierung dieser Funktion werden einige bislang noch nicht vorgestellte Funktionen und Typklassen von KiCS2 verwendet: 
\begin{itemize}
\item In der Typklasse \lstinline|NormalForm| fasst KiCS2 alle Typen zusammen, die sich normalisieren lassen. Da die Funktion \lstinline|searchFDCs| unmittelbar nach der Normalisierung eines Ausdrucks und vor dessen Auswertung durch eine Suchstrategie aufgerufen werden soll, wird ihr Argumenttyp durch das entsprechende Typklassenconstraint eingeschränkt.
\item Die Funktion \lstinline|match| stellt eine Alternative zur bereits vorgestellten \lstinline|try|-Funktion dar. Anstatt die Haskell-Darstellung eines Curry-Datentyps zunächst durch Aufruf von \lstinline|try| in einer generische \lstinline|Try|-Struktur zu überführen und dann auf dieser mittels Pattern Matching eine Funktion zu definieren, kann man mit Hilfe von \lstinline|match| auch direkt die entsprechende Funktion definieren. Dazu muss man sechs Funktionen - eine für jeden Konstruktor der \lstinline|Try|-Struktur (\lstinline|Val|, \lstinline|Choice|, \lstinline|Fail| etc.) - mit der gewünschten Funktionalität an \lstinline|match| übergeben. Sowohl \lstinline|match| als auch \lstinline|try| sind für verschiedene Typen überladen.
\item Die Funktionen \lstinline|choiceCons|, \lstinline|failCons|, \lstinline|guardCons| etc. sind überladene Konstruktorfunktionen. Das heißt abhängig vom gerade erforderlichen Typ liefert beispielsweise der Aufruf von \lstinline|failCons| einem \lstinline|Fail_C_Int|, einem \lstinline|Fail_C_Bool| etc.
\end{itemize}
Die Funktion \lstinline|searchFDCs| erwartet zwei Argumente: einen normalisierten, nicht-deterministischen Ausdruck sowie eine anfangs leere Liste zum Einsammeln der FD-Constraints. Ziel ist es, alle \lstinline|Guard|-Ausdrücke mit FD-Constraints aus dem gegebenen nicht-deterministischen Ausdruck zu entfernen, die Constraints dabei in der Liste zu sammeln und letztendlich eine einzelne \lstinline|Guard| für alle Constraints zu erzeugen.
\\
Implementiert wird \lstinline|searchFDCs| mit Hilfe der Funktion \lstinline|match|. Dazu werden vier Hilfsfunktionen angegeben:
\begin{itemize}
\item \lstinline|sfChoice| für binäre Standard-\lstinline|Choices|: Einsammeln der FD-Constraints in beiden Zweigen durch rekursiven Aufruf von \lstinline|searchFDCs|. Die \lstinline|Choice| wird über den resultierenden Teilbäume erneut konstruiert.
\item \lstinline|sfNarrowed| für n-äre Standard-\lstinline|Choices|: Rekursiver Aufruf von \lstinline|searchFDCs| zum Einsammeln der FD-Constraints in allen Zweigen, wobei die n-äre \lstinline|Choice| über den resultierenden Teilbäumen wieder aufgebaut wird.
\item \lstinline|sfGuard| für \lstinline|Guard|-Ausdrücke: Hier unterscheidet man, ob es sich um einen \lstinline|Guard|-Ausdruck mit einer Liste von \lstinline|FDConstraint|-Constraints handelt oder nicht. Falls ja, so wird die entsprechende Constraint-Liste an die Liste zum Sammeln aller FD-Constraints (\lstinline|fdCs|) angehangen. Danach wird der aktuelle Zweig durch rekursiven Aufruf nach weiteren Constraints durchsucht, wobei der \lstinline|Guard|-Knoten nicht wieder aufgebaut und somit aus dem Suchbaum entfernt wird.
\\
Enthält der \lstinline|Guard|-Ausdruck hingegen keine FD-Constraints, so wird zwar auch der aktuelle Zweig weiter durchsucht, allerdings wird die \lstinline|Guard| in diesem Fall mit denselben Constraints über dem durch \lstinline|(searchFDCs e fdCs)| gelieferten Teilbaum wieder aufgebaut.
\item \lstinline|sfVal| für konstante Werte: Erreicht man einen konstanten Wert \lstinline|v|, so hat man einen Pfad im Suchbaum vollständig abgelaufen. Das heißt, es kann ein neuer \lstinline|Guard|-Ausdruck erzeugt werden, der den konstanten Wert \lstinline|v| mit den gesammelten FD-Constraints \lstinline|fdCs| beschränkt. 
\\
Falls keine FD-Constraints eingesammelt wurden, so bleibt der \lstinline|v| unbeschränkt.
\end{itemize}
Stößt man beim Einsammeln der FD-Constraints mit \lstinline|searchFDCs| in einem Ausdruck auf einen Knoten, der eine freie Variable oder eine fehlgeschlagene Berechnung repräsentiert, so bleibt dieser Knoten erhalten und die Suche nach FD-Constraints wird in diesem Zweig nicht weiter fortgesetzt. Daher wird in diesen Fällen die entsprechende Konstruktorfunktion (\lstinline|choicesCons| bzw. \lstinline|failCons|) aufgerufen.
\par
Aufgerufen wird die Funktion \lstinline|searchFDCs| unmittelbar nach der Normalisierung eines Ausdrucks durch die KiCS2-Funktion \lstinline|getNormalForm|. Ein zu normalisierender Ausdruck wird durch eine Funktion vom Typ \lstinline|NonDetExpr a| repräsentiert, die einen \lstinline|IDSupply| und einen \lstinline|ConstStore| als Argumente erwartet. Der \lstinline|IDSupply| ist notwendig, falls der Ausdruck Nicht-Determinismus einführt und das \lstinline|ConstStore|-Argument wird für eine Optimierung beim Lösen von Curry-Bindungsconstraints benötigt. Nachdem der zu normalisierende Ausdruck mit einem frischen \lstinline|IDSupply| \lstinline|s| und einem leeren \lstinline|ConstStore| \lstinline|emptyCs| appliziert wurde, wird die Normalform durch Aufruf des \lstinline|($!!)|-Operators aus der Typklasse \lstinline|NormalForm| berechnet.
\\
Anstatt den resultierenden Suchbaum nun direkt zurückzugeben, werden zuvor durch Aufruf von \lstinline|searchFDCs| alle vorkommenden Finite Domain Constraints in einem einzelnen \lstinline|Guard|-Ausdruck gesammelt:
\begin{lstlisting}[language=Haskell,caption=Erweiterte Normalform-Berechnung]
type NonDetExpr a = IDSupply -> ConstStore -> a

-- Ergänzt um Aufruf von 'searchFDCs' zum Einsammeln
-- aller FD-Constraints
getNormalForm :: NormalForm a => NonDetExpr a -> IO a
getNormalForm goal = do
  s <- initSupply
  let normalForm = const $!! goal s emptyCs $ emptyCs
  return $ searchFDCs normalForm []
\end{lstlisting}
Die beiden folgenden Zeichnungen verdeutlichen das Verhalten der Funktion \lstinline|searchFDCs|, indem sie einmal den Aufbau eines Suchbaums (= nicht-deterministischer Ausdruck) vor dem Aufruf dieser Funktion und einmal danach zeigen.
\clearpage

\begin{figure}[!h]
\begin{center}
\begin{tikzpicture}
\node (n1) at (4.5,5.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Guard [FDCS1]|};
\node (n2) at (4.5,4.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|?|};
\node (n3) at (1.5,3.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Guard [FDCS2]|};
\node (n4) at (7.5,3.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|?|};
\node (n5) at (1.5,2.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Guard|};
\node (n6) at (5.5,2.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Guard [FDCS3]|};
\node (n7) at (9.5,2.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Guard|};
\node (n8) at (1.5,1.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Guard [FDCS4]|};
\node (n9) at (5.5,1.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Fail|};
\node (n10) at (9.5,1.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Guard [FDCS5]|};
\node (n11) at (1.5,0.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Val Success|};
\node (n12) at (9.5,0.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Val Success|};
\draw (n1) -- (n2);
\draw (n2) -- (n3);
\draw (n2) -- (n4);
\draw (n3) -- (n5);
\draw (n4) -- (n6);
\draw (n4) -- (n7);
\draw (n5) -- (n8);
\draw (n6) -- (n9);
\draw (n7) -- (n10);
\draw (n8) -- (n11);
\draw (n10) -- (n12);
\end{tikzpicture}
\end{center}
\caption{Suchbaum \textbf{vor} Aufruf von \lstinline|searchFDCs|} \label{linga}
\end{figure}

Wie man sieht, enthält der obige Suchbaum fünf \lstinline|Guard|-Ausdrücke mit Finite Domain Constraints. Beim Aufruf von \lstinline|searchFDCs| werden die einzelnen Pfade durch den Suchbaum abgelaufen. Dabei werden alle \lstinline|Guard|-Ausdrücke mit FD-Constraints entfernt und ihre Constraints eingesammelt. Die übrigen inneren Knoten wie Standard-\lstinline|Guards| oder \lstinline|Choices| (hier dargestellt durch \lstinline|?|) bleiben unverändert. Erreicht die Funktion am Ende eines Pfades einen deterministischen Wert (\lstinline|Val|-Knoten), so wird dieser durch Konstruktion eines neuen \lstinline|Guard|-Ausdrucks mit den bis dahin gesammelten Constraints beschränkt. 
\\
Beispielsweise werden beim Ablaufen des linkesten Pfades im obigen Suchbaum nacheinander die Constraints \lstinline|FDCS1|, \lstinline|FDCS2| und \lstinline|FDCS4| gesammelt und in einem neuen \lstinline|Guard|-Ausdruck zusammengefasst. Endet der Pfad hingegen mit einer fehlgeschlagenen Berechnung, so werden die gesammelten Constraints einfach verworfen und der \lstinline|Fail|-Knoten bleibt erhalten (Vergleiche mittlerer Pfad im Beispiel-Suchbaum).

\begin{figure}[!h]
\begin{center}
\begin{tikzpicture}
\node (n1) at (4.5,5.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|?|};
\node (n2) at (2.5,4.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Guard|};
\node (n3) at (6.5,4.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|?|};
\node (n4) at (2.5,3.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Guard [FDCS1,FDCS2,FDCS4]|};
\node (n5) at (5.5,3.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Fail|};
\node (n6) at (7.5,3.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Guard|};
\node (n7) at (2.5,2.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Val Success|};
\node (n8) at (7.5,2.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Guard [FDCS1,FDCS5]|};
\node (n9) at (7.5,1.5) {\lstinline[basicstyle=\footnotesize\ttfamily]|Val Success|};
\draw (n1) -- (n2);
\draw (n1) -- (n3);
\draw (n2) -- (n4);
\draw (n3) -- (n5);
\draw (n3) -- (n6);
\draw (n4) -- (n7);
\draw (n6) -- (n8);
\draw (n8) -- (n9);
\end{tikzpicture}
\end{center}
\caption{Suchbaum \textbf{nach} Aufruf von \lstinline|searchFDCs|} \label{linga}
\end{figure}
\clearpage

\subsubsection{Kombination von Finite Domain Constraints mit der Curry Unifikation}
Nun da man ein in Curry beschriebenes FD-Constraint-Modell letztendlich auf einen einzelnen \lstinline|Guard|-Ausdruck mit einer Haskell-Repräsentation dieses Modells abbilden kann, ist man eigentlich soweit einen konkreten Constraint-Solver in KiCS2 einzubinden. Zuvor soll aber noch auf die Möglichkeit eingegangen werden, die Finite Domain Constraints aus der CLPFD-Bibliothek mit den Curry-Bindungsconstraints bei der Modellierung eines Problems zu kombinieren.
\par
KiCS2 stellt in seiner bisherigen Form bereits ein Constraint zur Verfügung, nämlich ein Gleichheitsconstraint der Form \lstinline|(=:=) :: a -> a -> Success| (auch als Unifikationsoperator bezeichnet). Dabei ist ein Constraint-Ausdruck der Form \lstinline|e1 =:= e2| genau dann erfüllbar, wenn \lstinline|e1| und \lstinline|e2| zu unifizierbaren Konstruktortermen reduzierbar sind. Ausdrücke, die keinen Wert haben wie \lstinline|head []|, sind bezüglich \lstinline|(=:=)| \textbf{nicht} gleich.
\par
Die Frage ist nun, in welchen Fällen ist es sinnvoll, dieses Gleichheitsconstraint bei der Modellierung eines Problems mit den Finite Domain Constraints aus der neu eingeführten CLPFD-Bibliothek zu kombinieren? Zur Beanwortung dieser Frage betrachtet man erneut das N-Damen-Problem.
\\
Bislang wurde für die einzelnen Instanzen des N-Damen-Problems stets ein eigenes Modell definiert. Es wäre jedoch wünschenswert, dass man ein Modell findet, mit dem man durch Übergabe der Problemgröße als Parameter beliebige Instanzen beschreiben kann. 
\\
Dafür ist es erforderlich, dass man zur Laufzeit die notwendigen Constraint-Variablen und Constraints dynamisch in Abhängigkeit von der übergebenen Problemgröße erzeugen kann. Bei der Formulierung des 4-Damen-Problems (\textcolor{red}{$<$hier Verweis einfügen$>$}) wurden bereits Constraint-Funktionen verwendet, die in abhängig von der Anzahl der Constraint-Variablen die erforderlichen Constraints generiert haben (\lstinline|all_safe|, \lstinline|safe| und \lstinline|no_attack|). Somit benötigt man nur noch eine Funktion, mit der man eine entsprechende Liste von Constraint-Variablen erzeugen kann. Eine solche stellt die CLPFD-Bibliothek aber bereits in Form der Funktion \lstinline|genVars :: Int -> [Int]| zur Verfügung. 
\\
Ein Problem verbleibt jedoch noch: Die Liste der Constraint-Variablen zur Repräsentation der N Damen wird als Parameter verschiedener Constraint-Funktionen verwendet. Man kann jedoch nicht überall, wo ein solcher Parameter verlangt wird, \lstinline|genVars| aufrufen, da diese Funktion jedes Mal eine neue Liste von Constraint-Variablen erzeugt, was dazu führen würde, dass die Constraints über unterschiedlichen Variablen definiert würden.
\\
Lösen lässt sich dieses Problem durch Verwendung des Curry-Bindungsconstraints: Dazu erzeugt man einmalig mit \lstinline|genVars| eine Liste mit der gewünschten Anzahl von Constraint-Variablen und bindet diese dann mit Hilfe von \lstinline|(=:=)| an eine freie (Listen-)Variable. Diese freie Variable repräsentiert dann bei jeder Verwendung die gleiche Liste von Constraint-Variablen und kann somit als Parameter in den FD-Constraint-Funktionen des Modells benutzt werden:
\begin{lstlisting}[language=Haskell,caption=Beispiel: N-Damen-Problem]
queens n l =
       genVars n =:= l &
       domain l 1 n &
       all_safe l &
       labeling l

all_safe [] = success
all_safe (q:qs) = safe q qs 1 & all_safe qs

safe :: Int -> [Int] -> Int -> Success
safe _ [] _ = success
safe q (q1:qs) p = no_attack q q1 p & safe q qs (p+#1)

no_attack q1 q2 p = q1 /=# q2 & q1 /=# q2+#p & q1 /=# q2-#p
\end{lstlisting}
Die freie Variable \lstinline|l|, an die die Constraint-Variablen gebunden werden, übergibt man zusammen mit der Problemgröße \lstinline|n| bei Aufruf einer Instanz des N-Damen-Problems. Auf diese Weise werden einem bei einem Aufruf wie \lstinline|queens 4 l where l free| alle Lösungen in Form der verschiedenen Belegungen für \lstinline|l| angezeigt.
\par
Was genau passiert nun aber, wenn man einer Constraint-Funktion eine freie (Listen-)Variable als Parameter übergibt? Bei der Implementierungsbeschreibung der Constraint-Funktionen der CLPFD-Bibliothek wurde erklärt, dass Listen-Argumente wie Integer-Argumente zur Normalform ausgewertet, bevor sie an die jeweilige Constraint-Funktion übergeben werden. Zuvor werden sie allerdings noch in die sogenannte \emph{spine}-Form überführt. Dabei wird sichergestellt, dass die übergebene Liste endlich ist. Zudem wird durch Aufruf von \lstinline|ensureNotFree| garantiert, dass die Liste und auch keine ihrer Teillisten durch eine freie Variable repräsentiert wird. Falls doch eine freie Variable vorkommt, so wird die sie repräsentierende \lstinline|Choice| in KiCS2 mittels Narrowing in eine n-äre Standard-\lstinline|Choice| umgewandelt.
\begin{lstlisting}[language=Haskell,caption=Wiederholung: Auswertung von Listen-Argumenten in Constraint-Funktionen]
domain :: [Int] -> Int -> Int -> Success
domain vs l u = ((prim_domain $!! (ensureSpine vs)) $!! l) $!! u

ensureSpine :: [a] -> [a]
ensureSpine l = ensureList (ensureNotFree l)
where ensureList []     = []
      ensureList (x:xs) = x : ensureSpine xs
\end{lstlisting}
Die nachfolgende Berechnung der Normalform durch den \lstinline|($!!)|-Operator sorgt dafür, dass die durch das Narrowing neu eingeführten Standard-\lstinline|Choices| auf die Ergebnisebene propagiert werden, so dass die extern implementierten Constraint-Funktionen wie \lstinline|prim_domain| letztendlich wieder auf normalisierte, konstante Listenargumente angewendet werden. Somit können die Constraint-Funktionen der CLPFD-Bibliothek auch mit freien Variablen als Listen-Argumenten verwendet werden, ohne dass ihre bisherige Implementierung angepasst werden muss.
\par
Ein Problem gibt es bei der Verwendung des Curry-Gleichheitsconstraints in FD-Constraint-Modellen aber noch: Wird eine einfache Constraint-Variable in einem Curry-Modell einmal als Teil einer Liste von Constraint-Variablen in einem \lstinline|(=:=)|-Constraint und einmal in einem gewöhnlichen Finite Domain Constraint der CLPFD-Bibliothek verwendet, so kann es passieren, dass diese beiden Vorkommen der Curry-Variable auf unterschiedliche FD-Variablen im Haskell-Modell abgebildet werden. Um dies zu verdeutlichen, soll ein weiteres Constraint-Problem betrachtet werden, das \emph{send-more-money}-Rätsel.
\\
Beim \emph{send-more-money}-Rätsel ist es das Ziel, jeden Buchstaben mit einer Ziffer zwischen 0 und 9 zu belegen, so dass die folgende Gleichung erfüllt ist:
\begin{lstlisting}[language=Haskell,caption=SEND MORE MONEY Problem]
    S E N D
+   M O R E
= M O N E Y
\end{lstlisting}
Zusätzlich sollen keine zwei Buchstaben mit der gleichen Ziffer und die Buchstaben \lstinline|S| und \lstinline|M| mit einer Ziffer größer als Null belegt werden.
\\
Mit Hilfe der CLPFD-Bibliothek lässt sich dieses Problem wie folgt modellieren:
\begin{lstlisting}[language=Haskell,caption=Beispiel: SEND MORE MONEY (Curry)]
smm l = [S,E,N,D,M,O,R,Y] =:= l &
        domain l 0 9 &
        S ># 0 &
        M ># 0 &
        allDifferent l &
                         1000 *# S +# 100 *# E +# 10 *# N +# D
        +#               1000 *# M +# 100 *# O +# 10 *# R +# E
        =# 10000 *# M +# 1000 *# O +# 100 *# N +# 10 *# E +# Y &
        labeling l
        where S,E,N,D,M,O,R,Y free
\end{lstlisting}
Das Curry-Modell bildet das oben spezifizierte Problem exakt ab: Die acht verschiedenen Buchstaben aus dem Rätsel werden durch entsprechend benannte freie Variablen repräsentiert. Als Wertebereich werden die Ziffern von 0 bis 9 festgelegt, wobei die 0 für die Buchstaben \lstinline|S| und \lstinline|M| zusätzlich ausgeschlossen wird. Des Weiteren wird verlangt, dass alle Buchstaben paarweise verschieden sind. Die Summengleichung kann direkt übertragen werden. Es muss nur die Stelligkeit der einzelnen Buchstaben/Ziffern berücksichtigt werden.
\\
Wie auch schon bei der Modellierung des N-Damen-Problems bindet man die Liste der Constraint-Variablen im Curry-Modell an eine freie Variable, die man in den entsprechenden Constraint-Funktionen als Parameter übergibt.
\\
Betrachtet man nun das Haskell-Modell, auf das das obige Curry-Modell abgebildet wird, so erkennt man die Problematik:
\clearpage
