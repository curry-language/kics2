\section{Installation und Benutzung der KiCS2-CLPFD-Bibliothek}

\subsection{Installation}
Um die KiCS2 Finite Domain Constraint Bibliothek nutzen zu können, muss man zunächst eine KiCS2-Distribution mit der CLPFD-Bibliothek von \href{http://www-ps.informatik.uni-kiel.de/kics2/download/}{http://www-ps.informatik.uni-kiel.de/kics2/download/} herunterladen und installieren. Alternativ kann man auch eine aktuelle Version aus dem KiCS2-Repository herunterladen. Installationsanweisungen hierfür findet man unter \href{http://www-ps.informatik.uni-kiel.de/kics2/repos/}{http://www-ps.informatik.uni-kiel.de/kics2/repos/} oder auch in dem entpackten KiCS2-tarfile.
\par
Nun ist es noch erforderlich das Monadic Constraint Programming Framework, das als Solver-Backend für die CLPFD-Bibliothek verwendet wird, zu installieren. Um auch den Gecode-Solver verwenden zu können, sollte man allerdings zunächst die entsprechende C++-Constraint-Solver-Bibliothek installieren. Dazu lädt man von \href{www.gecode.org/download.html}{www.gecode.org/download.html} die gepackten Quelldateien der \textbf{Gecode Version 3.1.0} herunter. Es ist wichtig, dass man genau diese Version installiert, da das Monadic Constraint Programming Framework keine andere Version unterstützt.
\\
Zunächst entpackt man die Quelldateien mit
\begin{lstlisting}[language=bash,frame=no]
tar xzvf gecode-3.1.0.tar.gz
\end{lstlisting}
Dann ruft man das Konfigurationsskript auf:
\begin{lstlisting}[language=bash,frame=no]
cd gecode-3.1.0/
./configure
\end{lstlisting}
Schließlich kann man die Quelldateien kompilieren und danach Gecode installieren:
\begin{lstlisting}[language=bash,frame=no]
make
make install
\end{lstlisting}
Nach der Installation sollte man die Gecode-Bibliotheken noch zum \emph{library path} hinzufügen, damit die (Beispiel-)Programme richtig gelinkt werden können.
\\
Weitere Hinweise zu Gecode kann man unter \href{www.gecode.org/documentation.html}{www.gecode.org/documentation.html} in der Anleitung \emph{Modeling and Programming with Gecode} finden.
\par
Nun kann man das Monadic Constraint Programming Framework installieren. Dazu lädt man von Hackage DB (\href{http://hackage.haskell.org/package/monadiccp-0.7.4}{http://hackage.haskell.org/package/monadiccp-0.7.4}) die neueste Version 0.7.4 (Stand: Juli 2012) des Frameworks herunter. Nachdem man die Source-Dateien entpackt hat (\lstinline|tar xzvf monadiccp-0.7.4.tar.gz|), kann man die Konfiguration durchführen. Dabei muss man beachten, dass das Konfigurationsflag für die Installation der MCP-Gecode-Quelldateien gesetzt und der Pfad zu den Bibliotheken und Header-Dateien der Gecode-Installation angegeben werden muss, also zum Beispiel:
\begin{lstlisting}[language=bash,frame=no]
cd monadiccp-0.7.4
runhaskell Setup.hs configure --extra-include-dirs=
  /usr/local/include/ --extra-lib-dirs=/usr/local/lib/ 
  --flags="RuntimeGecode"
\end{lstlisting}
Nach erfolgreicher Konfiguration kann man die MCP-Pakete schließlich bauen und installieren:
\begin{lstlisting}[language=bash,frame=no]
runhaskell Setup.hs build
runhaskell Setup.hs install
\end{lstlisting}
Danach sollte man das Framework benutzen können. Zum Testen kann man nun eines der Beispielmodelle kompilieren und ausführen. Mit den folgenden Befehlen kann man beispielsweise das 4-Damen-Problem vom Gecode-Solver lösen lassen:
\begin{lstlisting}[language=bash,frame=no]
cd examples
ghc --make Queens.hs
./Queens gecode_run 4
\end{lstlisting}
Zuerst wird also der Solver-Typ angegeben (\lstinline|gecode_run|) und dann etwaige Parameter für das Constraint-Problem.
\subsection{Benutzung}
Bei der Modellierung von Finite Domain Constraints mit der CLPFD-Bibliothek sollte man einige Dinge berücksichtigen:
\begin{enumerate}
\item Ein CLPFD-Modell sollte im Allgemeinen folgende Form haben:
\begin{lstlisting}[language=Haskell,frame=no]
[<unification_constraints>] & <domain_constraints> & 
  <fd_constraints> & <labeling_constraint>
\end{lstlisting}
Als erstes gibt man etwaige Unifikationsconstraints für die Constraint-Variablen an, dann legt man ein Wertebereich für die Constraint-Variablen fest, danach folgen beliebige FD-Constraints über den eingeführten Constraint-Variablen und schließlich initiiert man deren Labeling durch Angabe eines "'Labeling-Constraints"'.
\item Die Unifikationsconstraints sind optional und können gegebenenfalls auch an anderer Stelle spezifiziert werden. Sie zuerst anzugeben kann jedoch den Lösungsvorgang beschleunigen, da diese Constraints während der Auswertung dann KiCS2-intern nicht verschoben werden müssen.
\item Für das Labeling kann - falls gewünscht - mittels des \lstinline|labelingWith|-Constraints eine spezielle Labeling-Strategie angegeben werden. Verwendet man stattdessen das \lstinline|labeling|-Constraint, so wird das Labeling der Constraint-Variablen in der gegebenen Reihefolge durchgeführt. Verzichtet man völlig auf ein "'Labeling"'-Constraint, so erhält man eine Fehlermeldung.
\item Weiterhin ist zu beachten, dass für sämtliche Labeling-Variablen auch ein Wertebereich festgelegt wird. Bei nicht Berücksichtigung wird ebenfalls eine Fehlermeldung ausgegeben.
\end{enumerate}
