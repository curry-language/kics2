\section{Grundlagen}
\label{chapter_grundlagen}



\subsection{Curry}
\label{section_curry}

\clearpage

\subsection{KiCS2}
\label{section_kics2}
KiCS2 (Kiel Curry System 2) ist ein Compiler für die funktional-logische Sprache Curry, der derzeit am Lehrstuhl für Programmiersprachen und Übersetzerkonstruktion der Christian-Albrechts-Universität zu Kiel von Michael Hanus und seinen Mitarbeitern entwickelt wird.
\\
Er kompiliert Curry-Programme in rein funktionale Haskell-Programme und nutzt den Glasgow Haskell Compiler als Back-End. Einerseits ermöglicht die Übersetzung nach Haskell die Wiederverwendung der Implementierung funktionaler Features wie die bedarfsgesteuerte Auswertung (lazy evaluation) oder Funktionen höherer Ordnung. Auf der anderen Seite hat man das Problem, dass Haskell keinen Nicht-Determinismus unterstützt, während in Curry nicht-deterministische Ergebnisse in jedem Berechnungsschritt vorkommen können. Daher müssen nicht-deterministische Berechnungen in Haskell implementiert werden.
\\
\\
Der KiCS2-Compiler löst dieses Problem, indem nicht-deterministische Werte explizit in Haskell-Datenstrukturen dargestellt werden. Dazu wird jeder Datentyp in Haskell um einen zusätzlichen Konstruktor \emph{Choice} erweitert, der die Auswahl zwischen zwei möglichen Werten repräsentiert.
\begin{lstlisting}[language=Haskell]
data Bool = True 
          | False
          | Choice Bool Bool
\end{lstlisting}
Damit lässt sich der nicht-deterministische Curry-Ausdruck \emph{aBoolCurry = True ? False}, der die beiden Ergebnisse True und False liefert, in Haskell direkt durch \emph{aBoolHaskell = Choice True False} darstellen. Wie bereits erwähnt, können nicht-deterministische Werte in Curry in jedem Berechnungsschritt vorkommen und somit auch als Funktionsargumente auftreten. Daher muss bei Funktionsdefinitionen über Pattern Matching eine zusätzlich Regel für das Vorkommen von \emph{Choice}-Argumenten eingeführt werden. Wie man im Beispiel sieht, wird dabei der Nicht-Determinismus von der Argumentebene auf die Ergebnisebene propagiert und die Funktion auf die beiden Möglichkeiten in der \emph{Choice} angewandt.
\begin{lstlisting}[language=Haskell]
not :: Bool -> Bool
not False = True
not True = False
not (Choice b1 b2) = Choice (not b1) (not b2)
\end{lstlisting}
Die bisherige Darstellung von nicht-deterministischen Werten hat allerdings noch einige Schwächen. So liefert der Ausdruck \emph{xorSelf aBoolHaskell} mit der unten angegebenen Implementierung von \emph{xorSelf} das folgende Ergebnis: \emph{Choice (Choice False True) (Choice True False)}
\begin{lstlisting}[language=Haskell]
xorSelf :: Bool -> Bool
xorSelf x = xor x x

xor True x           = xor